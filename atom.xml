<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>faceair 的博客</title>
  
  <subtitle>奋勇前行</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://faceair.me/"/>
  <updated>2018-11-02T05:49:07.717Z</updated>
  <id>https://faceair.me/</id>
  
  <author>
    <name>faceair</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>决胜延迟的最后一公里</title>
    <link href="https://faceair.me/2018/01/21/%E5%86%B3%E8%83%9C%E5%BB%B6%E8%BF%9F%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%85%AC%E9%87%8C/"/>
    <id>https://faceair.me/2018/01/21/决胜延迟的最后一公里/</id>
    <published>2018-01-21T07:29:00.000Z</published>
    <updated>2018-11-02T05:49:07.717Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是 1 月 16 日在公司准备的一次技术分享的 PPT 和讲稿，考虑到 PPT 文件或者视频不容易被浏览引擎索引所以整理成一篇博客供大家参考。</p></blockquote><p><img src="/images/决胜延迟的最后一公里/001.png" alt=""><br>大家好，欢迎各位来听这次分享。今天我分享的题目是“决胜延迟的最后一公里”。</p><p><img src="/images/决胜延迟的最后一公里/002.png" alt=""><br>我们大家都知道网站打开的速度严重关系着用户体验，根据 akamai 的一份报告显示，有约 50% 的用户会在等待页面加载 4s 后放弃访问，有 25% 的用户期望页面在 1s 内打开。各大厂商也都有类似的数据验证了这一点，当打开延迟增加时，用户的耐心也会大大降低，从而直接影响访问量甚至是收入下降。<br>那么我们应该怎么去提升用户访问速度呢？这个访问速度跟什么有关？</p><p><img src="/images/决胜延迟的最后一公里/003.png" alt=""><br>用户访问的速度跟很多因素有关，特别是请求到后端服务器以后，后面可能还要访问多层存储、程序内可能还有很多计算才能返回。但这其中的只看网络的速度的话，我们主要看两个因素：</p><p>一个是延迟，是数据分组从一端传到另一端所花的时间。这个时间主要跟两端的距离、传输介质、线路拥塞情况等因素有关。比如光的传播速度是 30w km/s，一般的玻璃的传输折射率是 1.5 的样子，换算下来光在光纤中的传播速度是 20w km/s。北京到深圳的距离与约 2000 km，那理论时延就是 10ms，但实际上我们 ping 到深圳的服务器去一般都要 40ms 的样子。这中间还有折射后实际传输距离改变、线路的实际架设距离、不同的运营商之间的互联互通等等问题。一般来说，我们很难定义好说一个地区访问另一个地区时延就是多少，我们心中可能有一个经验值，但它可能也会时时变化。</p><p>第二个是带宽。这个应该好理解，如果传输的所有中间环节都是串行的话，那带宽就是中间传输环节最窄的部分。但实际上大部分带宽的限制出现在靠近用户这一侧，上限一般就是网络运营商在路由上设的限制，或者是因为用户这边最后一公里传输介质不稳定导致带宽甚至达不到运营商的限制。</p><p><img src="/images/决胜延迟的最后一公里/004.png" alt=""><br>我们回应一下标题，来看一下什么是最后一公里。通信领域中的最后一公里指网络运营商机房交换机到用户设备的连接，也就是我们上一幅图中画的用户设备到 ISP 的相关连接。</p><p>最后一公里的接入方式最常见的有三种：</p><p>一种是以 IEEE 802.3 协议簇为代表的以太网，他们主要通过双绞线铜缆或者光纤连接，最高理论速度可以达到 100G bps。通过物理线缆连接的以太网很稳定，除了少量的电磁干扰外基本没啥需要特别注意和担心的。使用得当的话，以太网的速度还是有保证的，这也不是我们今天讨论的重点，我们先跳过。</p><p>第二种是以 IEEE 802.11 协议簇为代表的 WI-FI 网络，一般是在以太网上接一个无线路由器然后在 2.4GHz 到 5.8GHz 的频段上广播无线电信号，客户端跟它连接认证再传输数据。这里面会有很多原因导致数据传输不稳定，有延迟升高和带宽降低的现象，稍后我们来一一分析。</p><p>第三种是最常见的手机联网方式，全称是蜂窝式移动通信网络，从大家熟知的 2G 到现在的 4G 都是。最开始的移动网络架构上是将基站的分布设计成蜂窝的样子， 但因为技术迭代、用户分布和现实选址考量等等原因，我们现在的 2G、3G、LTE 网络已经不像“蜂窝”了，但为了习惯，大家现在一般还是这么称呼。蜂窝网络的架构在不断迭代和调整，延迟和带宽问题也在不断改善，但总体来说蜂窝网络架构下设备的联网方式跟以太网和 WI-FI 网络差异还是很大，后面我们再来具体分析。</p><p><img src="/images/决胜延迟的最后一公里/005.png" alt=""><br>我们首先看一下 IEEE 802.11 协议簇。IEEE 是电气电子工程师学会，是世界上最大的专业技术组织之一。他们在 1997 年为无线局域网制定了第一个版本标准 IEEE 802.11，之后在 1999 年在这个协议上新增了在 2.4GHz 频段工作的物理层叫做 802.11b。因为 2.4GHz 频段是世界上绝大多数国家都开放使用的公共的频段，所以 802.11b 马上就火了。</p><p>延伸一下，其实频段资源还是非常稀缺的。各国都出台无线电相关的法律法规集中管理和审批无线电频谱资源，通信公司往往都要花大价钱去买频段，比如美国的 700MHz 频段的使用权卖了 196 亿美元。大家能够自由使用的频段不多，刚好 2.4GHz 就在其中。</p><p>因为 IEEE 是一个技术型组织，并没有充足的人力、物力去推广 802.11b 协议。所以在 1999 年各厂商就联合起来成立了非盈利性的组织叫 WI-FI 联盟，负责测试和认证这些设备，设备能兼容的 802.11b 协议的就给它们打上 WI-FI 的 logo。后来还有不断的改进，新增了更多的频段、提升安全性、提升覆盖面积和传输速率，目前使用最广泛的标准应该是工作在 2.4GHz 下的 802.11n 和工作在 5GHz 下的 802.11ac。随着 802.11 新的标准和频段的使用，以及移动设备数量的迅猛增长，人们逐渐将 Wi-Fi 和 IEEE 802.11 整个协议簇等同起来，甚至和无线局域网络等同起来，严格意义上来讲是有一定区别的。</p><p>再讲个小故事。无线局域网 WLAN 的全称是 Wireless Local Area Network，实际上描述的是一种无线的组网方式。IEEE 802.11 协议簇是实现 WLAN 组网的其中一种最常见的标准，还有一种不常见的标准是 WAPI，全称很长我就不念了。这是中国政府在 2003 年发布的一种  WLAN 标准，随后工信部在国内强推 WAPI，2004 年发布禁令：禁止销售带有 Wi-Fi 模块的产品、带无线局域网的电子产品必须支持 WAPI。如果大家用手机比较早的话可能会有印象，那时候大家都会通过各种渠道找水货手机用，因为没有阉割 WI-FI 模块。现在国行 iPhone 和国内的 Android 手机上的显示还是无线局域网，港版或者美版的其他手机可能就直接显示的是 WI-FI，这也就是说这些手机现在还是同时支持了 WAPI 协议的，虽然你可能找不到一台支持 WAPI 协议的路由器。</p><p><img src="/images/决胜延迟的最后一公里/006.png" alt=""><br>背景大致介绍了一下，我们回到正题来。</p><p>无论使用哪种无线技术，所有通信方法都有一个最大的信道容量。这个容量是指信道在单位时间内可以传输的最大信号量，实际上描述的就是我们通常意义上的带宽。信息论之父克劳德·香农对信道容量给出了一个确切的数学模型，这个模型有着具体的传输技术无关性。</p><p>从这个公式中可以看到左边的 C 是信道容量，右边的 B 是可用带宽， S 是信号功率，N 是噪声功率。<br>其实这个公式也符合直觉，总共有三种情况：</p><ol><li>当信噪比不变的情况下，提升可用带宽 B 能提升信道容量。</li><li>当发射功率 S 和可用带宽 B 不变的情况，噪声功率 N 越低，信道容量越高。</li><li>当噪声功率 N 和可用带宽 B 都不变的情况，增加信号功率 S 可以提升信道容量。</li></ol><p>这里面实际对应了我们常见的 WI-FI 信号优化的思路：</p><ol><li>买个更好的支持理论速度更高的路由器，算是提升可用带宽</li><li>将路由器发射信道换到干扰较少的信道，算是降低噪声功率</li><li>买信号放大器增大信号发射功率，是提升信号功率</li></ol><p>如果要提升可用带宽达到协议的上限速度，一般需要选择路由器支持到较新的协议。比如 2.4GHz 下 802.11n 协议的上限 300M bps，如果是换到 5GHz 的话 802.11ac 协议的上限就直接提到了 867M bps。</p><p>提升信号功率应该也好理解，一般就是离路由器太远了，发射功率太低或者是信号频率高 5G WI-FI 穿墙性能不太行，这种可以买信号放大器、尽量离路由器近点才能解决。</p><p><img src="/images/决胜延迟的最后一公里/007.png" alt=""><br>IEEE 802.11 协议设计的有参考 802.3 以太网协议，所以它们都有一个相同的特性，就是自我控制能力。以太网和 Wi-Fi 都把传输的媒介视为“随机访问通道”，即没有调度中心控制哪台设备在哪个时刻可以发送数据，所有设备都自我控制，协同工作，共同维护共享信道的性能。Wi-Fi 采用的是一种冲突避免机制，即每个发送方都会在自己认为信道空闲时发送数据，以避免冲突，当发生信道冲突时，随机一段等待时间再进行重试。换一句话说，如果你跟邻居的路由器使用了同样的信道，而且他正在看高清直播，你们传输数据的时候发送冲突，那你的带宽可能就会减至一半，甚至还不到一半，这就是 WI-FI 的冲突避免的 feature。如果你自己要检查是否有干扰的话，一般在电脑上 ping 一下无线网关就能确认延迟和丢包率。</p><p>所以如果是要减少冲突减少噪音，那就需要使用这个信号频段内的电子设备越少越好。首当其冲要看的就是工作在同一频段的其他路由器，比如 2.4GHz 下的 IEEE 802.11 协议簇下的大部分协议都分了 13 个信道，它们的中心频率不同，但都占据了一定的频率范围，信道也会有一部分是重叠的。如果大量的路由器都使用了相同的频率，就会产生上面图这样的效果。另外常见的电磁炉和蓝牙也是工作在 2.4GHz 下，他们工作的时候也可能就会干扰 2.4G WI-FI 工作。<br>5GHz 的路由器信道各个国家划分标准不太一致，但总体来说可以用信道更多，有效频率范围也能达到更高，目前还不太拥挤。同时因为 5G 信号频率高传播衰减快，也不太容易干扰到别人，右边图可以看到我家附近能收到 5G 信号的路由器就只有我的一个，就不用太担心干扰啦。</p><p><img src="/images/决胜延迟的最后一公里/008.png" alt=""><br>OK，那我们最后来总结一下 WI-FI 网络的特点：</p><ol><li>因为冲突避免策略，所以不能保证带宽和延迟</li><li>因为不同环境下信噪比差异很大，所以带宽无法预测和保证</li><li>根据国家颁布的《无线电管理条例》来说 5G 频段的发射功率限制在 200mW 以内， 2.4GHz 频段发射功率限制在 100mW 以内，很多放大器强行增加信号发射功率其实违法</li><li>信道频宽重叠刚才有描述</li><li>大家也有经验，大型会场的 WI-FI 无线信号很难保证，其实有一部分原因就是客户端发射频率一致互相干扰导致的</li></ol><p>最后总结一下，就是不同环境下的 WI-FI 网络差异很大，很难保证带宽和延迟，所以速度也很难预期</p><p><img src="/images/决胜延迟的最后一公里/009.png" alt=""><br>最后一种最后一公里的通讯方式是蜂窝网络，它跟 WI-FI 一样都是通过无线电波传播，但也有很大的差异。</p><p>蜂窝网络的不同制式工作在不同的频段上，比如常见移动、联通、电信的 4G 制式 FDD-LTE 和 TDD-LTE 分布在 1600MHz-3800MHz 的频段上，跟 WI-FI 最大的区别是各运营商的频段是早就分好了，信号干扰较少。而且根据《无线电管理条例》的规定不允许其他人在这些频率上发射信号。</p><p>根据刚才的香农公式分析，当噪音功率固定而且很低的时候，影响信道容量的就只有信号功率和可用带宽两个因素了。2G 到 3G 到 4G 制式的升级会带来可用带宽的提升和延迟的大大降低，所以升级到最新的网络制式是一个很好的提速办法。</p><p>另外一个信号功率跟两个因素有关：一个是用户设备到通讯基站的距离，另一个是运营商使用的信号发射频率。<br>第一个到基站的距离好理解，运营商也通过架设更多的基站来增强用户设备收到的信号功率。<br>第二个信号发射频率怎么理解呢，一般我们知道无线电频率越高理论带宽越大但信号衰减也越快，频率低一点可以获得更大的覆盖范围。在 2G、3G 时代运营商使用了更低的发射频率，比如 2G 工作在 800-900 MHz，能获得很广的覆盖范围，同时问题是上网速度不怎样。到 4G 时代，信号发射频率升高覆盖范围变小，必然需要架设更多的基站，带来的是高额的成本。<br>而实际上 4G 协议规定的还有个 700 MHz 的频率是可以使用的，也就是我们刚才说过的在美国卖了 196 亿美元的频段，这个频率在中国是分给了广电总局的。广电又没有能力利用起来，各家运营商都非常眼红，如果他们能拿到这个频率的使用权，那在一些偏远地区支持 4G 可以少架基站，这些地方因为人少也不需要非常高的带宽，能减少大量的成本。前两天还看到有新闻说广电要拿这个 700 MHz 频段的使用权换联通的股份，感觉有点略流氓。</p><p>好了，说回来。除了自己找运营商升级网络制式，再等运营商架基站外，还有影响移动网络速度的因素吗？</p><p><img src="/images/决胜延迟的最后一公里/010.png" alt=""><br>还有一个非常重要的因素就是 Radio Resource Control，简称 RRC，翻译过来就是无线资源控制。RRC 全权负责设备在什么时候能发射信号，带宽多大，功率多少，以及监控设备的电源状态等。简而言之，RRC 就是无线电网络的中枢。想要通过无线信道发送数据？你必须先向 RRC 申请无线电资源。想要接收互联网上的数据？RRC 会通知你什么时候监听接收到来的分组。</p><p>为什么要有 RRC 这么一个机制呢，主要是为了省电。无线电在任何手持设备中都是最耗电的组件之一。要说最耗电，应该是点亮的屏幕，但在实际使用中，屏幕一般情况下都是熄灭的，反倒是无线电组件，为了让用户有“永远在线”的体验，必须一直运行。<br>实现这个目标的一种方式就是让无线电组件不停地工作，可这么干会疯狂地消耗电量，用户设备的续航完全没法保证。而且 3G 和 4G 的最新版本要求并行传输，这相当于同时开启了多个无线电组件，同时考虑到要覆盖更大范围以及排除干扰，这两个网络在通信时要求的最高功率甚至会达到 1000～3500 mW。<br>所以一直工作很难达到，所以通过 RRC 来通知设备什么时候启用无线电组件，什么时候休眠无线电组件。</p><p>上图中描述的是 LTE 制式下的 RRC 状态机，其他制式下可能略有差别，但大部分的原理还是共通的。当设备要准备传输数据了先要通过 RRC 申请资源，等确定可以发送数据了开启无线电组件，等待一段时间都进入短休眠状态，再等一段时间看情况进入活跃或者长休眠状态。这个描述的长短休眠状态下无线电组件实际也是耗电的，只不过不是满载运行功率会略低一点，最后如果不需要发送数据了等待 10s 释放所有的资源进入空闲状态。也就是说每发送一次数据都会至少激活无线电组件 10s 的时间，如果设备频繁被唤醒发送数据，就可能造成电量的大量消耗，我们的客户端编程中也需要注意这一点。</p><p>剩下的我们来聊一下信令风暴吧。大家以前应该听说过微信信令风暴的传闻，当时听说运营商约谈了微信，要对微信收取费用，还有传言微信要把这笔费用转嫁到用户身上，为什么会发生这样的事情呢？通过我们刚才的分析，应用要发送一次数据要通过 RRC 指令申请无线信道资源，RRC 的协议还要经过几个 RTT 的握手，基站要和后面的网关要为请求准备资源，实际上消耗还是挺大的。等连上以后，微信收发几个数据包确认没有新的消息马上就休眠了。当微信的用户量变大了以后，应用的心跳太频繁，运营商基站不堪其扰，信令太多了超过了能承受的负载。而且严格来说运营商的线路和无线电信道是一种分时系统，不同的用户间交替使用，本来是应该按占用和使用时间来收费的，但现在运营商是按流量来计费，心跳包体积很小微信的使用的流量又上不去，传闻是微信占用了中移动 60% 的信令资源，但仅带来 10% 的移动数据流量，导致运营商也很头疼。后来微信主动降低了心跳包的频率，运营商也开始升级基站配置这事就算不了了之了。</p><p><img src="/images/决胜延迟的最后一公里/011.png" alt=""><br>刚才既然说到 RRC 要握手，那自然也是需要消耗时间的。4G 网络的 RRC 状态从空闲切换到活跃状态最低要用 100ms，这个切换延迟我们称为控制面延迟。<br>为什么要说是最低 100ms 呢？当基站繁忙的时候 RRC 有可能会拒绝你的状态切换请求。大家可能会有经验，在人员过于密集的场所，手机可能会上不了网，这就是无线信道资源配额已经用完了，RRC 把你的状态切换请求拒绝了。<br>另外的还有用户面延迟是指分组到信号塔的时间，一般小于 5ms，但如果信号功率不够或者受到的无线电干扰严重可能会发生重传无法准确保证时延。前面说的 4G 信号频率高衰减快，在地铁上或者基站覆盖不太好的地方，信号很可能已经衰减到没有了，手机就只能 fallback 到 3G、2G 上，2G 频率低衰减慢所以总是有信号，如果信号回落到 2G 了延迟就更没法保证了。<br>最后分组再从信号塔传输到网关再传到具体的服务器，这个的时延因具体的运营商线路不同而不同，也不太好统一描述。<br>所以总结一下蜂窝网络在第一次发起请求或者空闲超过 10s 无线电模块休眠后发起请求的时延可能无法保证，因为中间 RRC 状态切换时间无法预期，建立连接后的传输时延要看信号功率的强弱以及运营商线路才能确认。</p><p><img src="/images/决胜延迟的最后一公里/012.png" alt=""><br>前面我们分别介绍了两种无线通讯方式，还有一种情况是这些通讯方式互相地来回切换。在正常的使用中我们可能比较少切换网络，但如果对这种临界状态处理的不好的话，很可能会出现一些奇奇怪怪的问题。<br>上面图中介绍了一些常见的网络切换情况下网络的表现。<br>简单的描述是手机上的移动网络是一直保持活跃的，当连接上 WI-FI 后，虽然默认网关指向 WI-FI 热点的 IP， 但已建立的连接依然走 4G 网络，不受影响。<br>但如果连接是在 WI-FI 网络下创建的，当断开 WI-FI 以后网口会直接 down 掉，热点 IP 也连不通了，所以当 TCP 连接再有数据传输的时候会收到 reset 包，需要应用重新建立连接。</p><p><img src="/images/决胜延迟的最后一公里/013.png" alt=""><br>再给大家介绍两种特殊情况：</p><ol><li>理论上当和基站通讯中断一段时间内，RRC 会话和 IP 租约都会保持，这个时候恢复信号或连接新的基站，甚至在 2G、3G、4G 之间切换都不会因此中断。但实际能否保持连接，取决于基站附近移动设备数量。我跟江泽在六道口地铁站测试信号中断时，除中午时间容易保持连接外，下午 3 点到晚高峰都会 100% 链路关闭或者 IP 变化。</li><li>当出现高丢包，但链路并未关闭时，如果对方认为手机已发呆超时，会主动关闭连接，图中黄叉情况。此时运营商网关会认为连接已关闭，停止进行 NAT 服务。信号恢复时。客户端 TCP 会认为连接依然存在，但此时发送的任何数据都会被网关丢弃。应用表现为连接还在，但无响应，客户端开始无限转圈圈，不会收到任何错误。</li></ol><p><img src="/images/决胜延迟的最后一公里/014.png" alt=""><br>所以呢，客户端在编程的时候要处理处理好网络切换的状态。<br>一般 iOS 和 Android 客户端上都有相关的 Reachability API，可以监听相关网络切换的事件发生，然后新建一条连接并对正在进行的幂等网络请求进行安全地重试，这样可以做到尽量平滑的过渡。<br>另外可以开启 TCP_KEEPALIVE 选项，允许 TCP 协议栈对连接进行保活，可以尽快发现死连接。<br>应用层的超时时间也需要梳理一下，避免无限等待，该重建连接重试的时候就果断重试就好了。</p><p><img src="/images/决胜延迟的最后一公里/015.png" alt=""><br>最后我们总结一下。我们刚才着重分析了最后一公里的两种无线通讯方式，一种是 WI-FI 网络，另一种是蜂窝网络，这两种也是移动设备最常见的上网方式。<br>它们有着这样的特点：因为信道干扰和冲突避免策略，WI-FI 网络的延迟和丢包可能在毫秒级到秒级，丢包率可能有非常大的波动，带宽也无法保证。蜂窝网络因为 RRC 机制、信号功率和制式的降级的不确定性也无法保证延迟和带宽。<br>总而言之，我们应该明确一点：移动网络有着非常多的不确定性，不同的用户所处的环境下网络状态难以保证。我们在设计产品的应该充分考虑到这一点，不要对用户的移动网络稳定性做过多的期待和假设。</p><p>可能大家对我说的说的这些没有感触，我们在北京可能平时的信号都还挺稳的，甚至在地铁里都能保证全称 4G 连接，但并不是所有的地方的基础通信设施覆盖都这么全，网络都这么稳定。比如我们站上的学生用户们，他们在宿舍一层楼可能有大量的路由器工作在同一频道上，可能校园网禁止路由器拨号只能用电脑软件来发射 WI-FI 信号，甚至出口带宽也是共享的，这些情况下网络的质量很难说；而运营商网络，比如联通的互联网套餐开始普及了以后很多地区的基站是超负荷运转的，RRC 的切换时间很难保证，信号满格但就是上不了网等等情况。</p><p>如果我们想让 App 在各种网络情况下都能快速加载，那针对弱网条件的适配是必不可少的。那我们在考虑优化客户端在移动网络下的性能的时候，能做的优化有哪些呢？</p><p><img src="/images/决胜延迟的最后一公里/016.png" alt=""><br>我挑了一个 Chrome 加载资源的一个时序图，用来展示一个完整的 HTTP 请求所需要的过程。在不同的平台下可能略有差异，但总体来说都是差不多的，那我们就以此分析一下。</p><p>因为并发限制，请求会有一个入队等待的过程，我们看到的这个请求等待了 0.69ms。然后紧接着是进行 DNS 查找，因为命中了 Chrome 内建的 DNS 缓存，所以这个时间只花了 6us (微秒)。再然后是初始化连接花了 2.33s，其中大片的时间是在进行 SSL 握手。请求初始化完毕后，客户端发出请求，花了 0.16ms。这个时间为什么这么短呢，因为这个是表示的浏览器将 HTTP 协议请求数据通过系统调用传给了 TCP 协议栈，存到 TCP 的缓冲区的时间，并不代表 TCP 将所有的数据都成功发送出去了。所以后面的等待时间是略有误差的，TTFB 的全称是 Time To First Byte，表示收到服务端返回的首字节的时间。最后一个时间分片表示浏览器接受到完整的 HTTP 响应所花的时间。</p><p>这些过程其实大家可能都理解，那么我们应该采取哪些措施去优化这些传输的中间过程？</p><p><img src="/images/决胜延迟的最后一公里/017.png" alt=""><br>我们首先来看一下 DNS Lookup 过程是怎么完成的。</p><p>如果没有命中应用内建的 DNS 缓存，那么应用会向操作系统会发起一个 gethostbyname 系统调用，然后操作系统会准备好 DNS 查询的报文通过 UDP 协议发给本地 DNS Server。本机的 DNS Server 的是在获取本机 IP 的时候从上级 DHCP 服务拿到的，蜂窝网络下是通过 APN 配置拿到的，这个 DNS 一般是给你提供网络的运营商提供的。然后 DNS Server 会从根域名逐级递归地找到你的域名服务器然后再查询到你访问域名的目标 IP。这中间 DNS Server 的递归查询环节多耗时非常的不可控，而 gethostbyname 的系统调用本身即没有提供超时控制，也控制不到 DNS Server，所以一般在应用层做的超时设置粒度非常粗。<br>另外我们在前面讨论提到了，无线网络可能丢包率和延迟都高。而 UDP 协议本身是不会重传的，如果中间环节发生了丢包，这边要等到应用层的超时之后才能觉察和重试，非常的迟钝。<br>另外还有一个问题是运营商故意的劫持或者是技术问题常常会导致他们维护的本地 DNS Server 解析到错误的 IP，这种解析失败不一定会覆盖到别的网站，用户体验上可能就觉得就是我们的网站挂了，也没有动力第一时间去找运营商投诉。</p><p>那么有什么办法杜绝这些问题吗？</p><p><img src="/images/决胜延迟的最后一公里/018.png" alt=""><br>业界常见的方案大概有两种，一种是 HTTPDNS，另一种是通过一个固定 IP 的机器下发各域名全量的 IP 列表。<br>我们目前是使用的阿里的 HTTPDNS 方案，DNS Server 由阿里提供和维护，相对于依赖全国各地的运营商，阿里提供的企业服务会更加可靠一些，TCP 协议也有分组级别的重传相对会更加可靠一些。<br>另一种直接下发 IP 列表跟 HTTPDNS 比较类似，区别是自己来维护，同时解决单点故障的时候这种客户端级别可以直接 fallback 到其他节点会更灵敏和健壮一些。</p><p><img src="/images/决胜延迟的最后一公里/019.png" alt=""><br>DNS 的问题说完了，接下来要通过 TCP 协议建立连接了。<br>所有 TCP 连接一开始都必须经过三次握手。客户端与服务器在交换应用数据之前，必须就起始分组序列号，以及其他一些连接相关的细节达成一致。出于安全考虑，序列号由两端随机生成。一般至少需要一次 RTT（Round-Trip Time，往返时间），后面客户端再 ACK 的时候就可以带上数据了。<br>但是根据我们的编程习惯，如果是使用阻塞 socket，在连接完成之后 connect 调用才会返回才能向 socket 中写入数据。或者如果是设置为非阻塞 socket，我们需要在 connect 后立即往 socket 中写入数据才有可能在第三次 ACK 的时候带上数据，否则等连接成功的事件再写就迟了。所以第三次 ACK 时候带上数据这个 feature 其实比较难利用上。</p><p><img src="/images/决胜延迟的最后一公里/020.png" alt=""><br>所以呢，为了在降低 TCP 握手时延的影响，也为了尽快开始发送数据。Google 的几位大佬提交了 RFC7413 对 TCP 对协议进行了拓展，支持了 TCP Fast Open 选项。Linux Kernel 在 3.7.1 之后已经支持开启 TCP Fast Open。<br>TCP Fast Open 的开启后握手的过程大概是这样的：</p><ol><li>先使用普通的 TCP 三次握手建立连接一次，但是这个过程中 TCP Server 会分配一个 cookie 给 Client，Client 将这个 Cookie 保存起来</li><li>TCP Client 使用 Cookie 构造 TCP Fast Open 握手包，这个时候正式开始 Fast Open 的流程</li><li>TCP Server 对 Client 的 Cookie 进行验证，验证通过则正常交流，不通过则忽略<br>时延长而且不稳定的网络都建议开启 TCP Fast Open，类似的 Shadowsocks 的 Wiki 里也建议了开启 TCP Fast Open。</li></ol><p>据我查到的资料是 TCP Fast Open 在 iOS 9 开始支持，Android 端受限于 Kernel 的版本目前还只有部分手机支持。已知的有 Chrome 浏览器在各端的 App 上的 TCP 协议栈都是他们自己做的，所以能方便的开启 TCP Fast Open。而 Server 端开启 TCP Fast Open 也不是太方便，知乎现有的后端与客户端通讯的网关和 CDN 节点都不是自建的，也要依赖多家第三方服务的供应商来开启。所以这个特性也不是太好利用起来。</p><p><img src="/images/决胜延迟的最后一公里/021.png" alt=""><br>说完了 TCP Fast Open 我们再来看一下 TCP 的拥塞控制，这里我简述一下 TCP 拥塞控制相关的概念。</p><p>TCP 拥塞控制的目标是最大化利用网络上瓶颈链路的带宽，那首要目标就是要测量带宽。<br>网络链路就像水管，要想用满这条水管，最好的办法就是给这根水管灌满水，灌满了就能得到这样一个公式：水管的容积 = 水管粗细 × 水管长度 换成网络的理解，也就是：网络链路上能容纳的数据包数量 = 链路带宽 × 往返延迟，这也就是带宽延迟积。<br>经典的 TCP 拥塞算法当想测量带宽延迟积的话也就是拼命往连接上写数据，一直写到开始丢包，这个时候认为达到了带宽延迟积的上限，再除以 RTT 就能算出来带宽。</p><p>经典的 TCP 的拥塞控制由 4 个核心的算法组成：慢启动、拥塞避免、快速重传和快速恢复。图中的状态切换非常复杂，我捡最重要的描述一下。</p><ol><li>慢启动的主要思路的探测网路的拥塞程度，每当报文被确认的时候，发送窗口就增大一倍，当发送窗口大于慢启动阈值启动过程结束，进入拥塞避免阶段</li><li>进入拥塞避免状态后发送窗口是线性增长不再指数增长</li><li>不管是在上面说的慢启动还是拥塞避免的状态，只要判断发送方出现丢包，就会将慢启动阈值设为当前发送窗口的一半，发送窗口值设为初始窗口大小，再重新进入慢启动</li></ol><p>还有一条比较重要的线是快速重传和快速恢复：</p><ol><li>快速重传指 TCP 在收到一个乱序的报文段时，会立即发送一个重复的 ACK，并且这个 ACK 不会被延迟，如果连续收到 3 个或 3 个以上重复的 ACK，TCP 会判定报文段丢失，需要重新传</li><li>快速恢复是指快速重传后直接进入拥塞避免阶段而非慢启动阶段</li><li>这部分的思路是能收到三次重复的 ACK，虽然有丢包但也说明网络状况不那么糟糕，所以跳过慢启动状态，直接从拥塞避免状态开始，发送窗口也降得少一些。</li></ol><p>这两部分的算法的都有一个预设的判断在里面，就是认为当发现丢包的时候就认为发送带宽已经被占满了，所以我们的 TCP 连接要主动地降低发送窗口降低发送速度，避免链路拥塞。<br>但根据我们刚才对无线网络的分析这个思路还成立吗？如果是 WI-FI 的信道被强占了，可能等几秒你又能抢到空闲了，这个时候你的带宽是充足的，但你的 TCP 连接可能已经开始了慢启动，你要等好几个包的传输才能达到理论带宽。如果是蜂窝网络，你可能在行驶的地铁上刚好某段信号强度较弱，这个时候 TCP 开始慢启动，然后等信号好了你还是要等待 TCP 慢启动完成。如果是时延较长的网络，慢启动带来的影响会更大，要等待更长的时间来恢复。<br>其实 TCP 算法也不算错，至少开始慢启动的时刻确实理论带宽是低的，问题是 TCP 的慢启动策略还是太过保守，不能适应信号有一定波动的网络。<br>下面我给大家介绍另外两种比较有意思的拥塞控制算法，对这个问题分别给出了自己的答案。</p><p><img src="/images/决胜延迟的最后一公里/022.png" alt=""><br>第一种是 KCP，大家在 Github 搜一搜应该能搜到。目前在科学上网领域比较火的，另外的网易的几个视频直播项目和几个商业游戏中有使用。</p><p>它主要改进的点是计算超时更保守、丢包选择重传、不延迟 ACK、不退让流控。跟 TCP 相比牺牲了部分公平性，在传输小数据的时候更加激进，它在 Readme 中的介绍是浪费以 10%-20% 的带宽的代价，换取平均延迟降低 30%-40%。在传输数据量小而且在对延迟要求尽量低的网络条件下，这个协议比较粗暴，但也足够好用。</p><p><img src="/images/决胜延迟的最后一公里/023.png" alt=""><br>当大家都意识到丢包不再表示拥塞的时候，Google 的大佬们又提出了 BBR 拥塞控制算法。</p><p>根据定义当网络上的包数大于带宽延迟积时，就出现了拥塞。所以重点就在于如何准确地测量出瓶颈链路的带宽和整个链路的传播时延。<br>BBR 测量带宽和延迟的方法是交替测量带宽和延迟，用一段时间内的带宽最大值和延迟最小值作为估计值，所以有少量的丢包不会影响到带宽延迟积的计算，理论上在丢包率较高的的线路上使用 BBR 会比传统的 TCP 拥塞控制算法会更能充分利用带宽。<br>而 BBR 也不再像传统的 TCP 拥塞算法一样拼命地往链路上写数据，所以链路上的堵在各个路由缓冲区的数据包会更少，延迟也会有降低。</p><p><img src="/images/决胜延迟的最后一公里/024.png" alt=""><br>TCP 协议太复杂了，这里没法对所有的细节面面俱到，我们只总结了对性能影响比较大的几个因素：<br>第一个前面没有描述，但也是显而易见的。请求数据包最好能一次就发出去，移动网络下 RTT 可能要数百毫秒甚至可能都比后端的接口响应时间都要长，不然的话就要等一个 RTT 或者几个 RTT 后数据包收到服务端的 ACK 报文后才能继续发，这样的话就等太久了。<br>TCP KeepAlive 前面讲 Reachability 的时候也描述过，就不再赘述了。<br>剩下的几项我们前面也都有讨论，分别是尽量复用连接，启用 TCP Fast Open 和启用一些对丢包容忍度高或做过优化的拥塞控制算法。</p><p><img src="/images/决胜延迟的最后一公里/025.png" alt=""><br>HTTP 1.1 协议比较简单了，我们之前做过一些对比实验，比如：</p><ol><li>HTTP 长连接与短连接，在不同延迟下性能对比</li><li>HTTP Pipeline 与并发短连接，在不同延迟下性能对比</li><li>HTTP 不同请求响应大小，在不同带宽下对响应时间影响</li><li>HTTP 并发连接，在不同的带宽下响应时间对比</li><li>HTTP 在不同丢包率下对响应时间的影响<br>也得到了一些结论，也都挺符合直接的，没有太多需要额外解释的。<br>这里我总结一下就是：开启 Keepalive、开启 Pipeline、连接保活和预建连接。</li></ol><p><img src="/images/决胜延迟的最后一公里/026.png" alt=""><br>前面我们看了一个 Chrome 加载的时序图，其中 SSL 的握手花了非常久的时间，为什么呢？<br>SSL 层在 TCP 层之上，在完成 TCP 的握手之后开始传输  SSL 加密数据。SSL 层还需要握手，中间有数次 RTT 的数据传输，还有证书的交换，在丢包率高的网络下还可能发生重传。HTTPS 连接的初始化确实会比 HTTP 慢很多。<br>这里我们大致看一下 SSL 握手的流程：</p><ol><li>客户端向服务端发送 Client Hello 消息，消息中包含了 SSL 协议的版本号，客户端支持的加密算法列表以及一些其他 SSL 可选项</li><li>服务端从客户端提供的算法列表中选择一个做为后续内容加密的算法，并向客户端发送服务端的证书</li><li>客户端校验服务端提供的证书，并向服务端发送加密的对称加密 Key</li><li>服务端校验客户端发送过来的相关信息并发送完成消息</li><li>客户端开始和服务端在建立加密通道上进行数据交换<br>但这两次 RTT 时间确实有点太长了，如果客户端到服务端的延迟是 50ms 那就至少需要 200ms 后客户端才能发出请求。</li></ol><p><img src="/images/决胜延迟的最后一公里/027.png" alt=""><br>TLS 是有会话的概念的，会话中包含了协商好的加密算法和对称加密 Key 的信息，所以可以通过复用 Session 来减少握手次数。<br>Session 的存储方式也有两种，一种是叫 Session ID 是内容存储在服务端的 Session Cache 中的，另一种是叫 Session Ticket 是用服务端秘钥加密然后存储在客户端中的。建议优先使用 Session Ticket 方式来复用会话，Session Cache 可能会遇到多节点会话信息存储不共享和遇到服务端 Sesssion Cache 空间不足的问题难横向扩展，不过需要注意保证服务端密钥的安全。</p><p>我们说回来，看一下当复用 Session 的时候握手的流程是怎样的</p><ol><li>客户端发送 Client Hello，并在 SSL 拓展中带上复用 Session ID 或者 Session Ticket</li><li>服务端发送 Sever Hello，并向客户端确认 Session 和加密算法</li><li>客户端收到确认后就可以在加密通道上交换数据了<br>这样的话 SSL 握手就减少到一个 RTT 了。</li></ol><p><img src="/images/决胜延迟的最后一公里/028.png" alt=""><br>除了 SSL 会话复用以外，还有 TLS False Start 选项也可以达到类似的 1 RTT 的效果。<br>TLS False Start 是指客户端在确认使用的加密套件和加密 Key 的同时发送应用数据，服务端在 SSL 握手完成时直接返回应用数据。这样，应用数据的发送实际上并未等到握手全部完成，所以也称为抢跑。<br>跟 Session 复用相比区别不算太大，但 TLS False Start 会多传输一个证书，如果证书大小优化不好的话传输可能会更加耗时。</p><p>TCP 握手我们能优化到 0 RTT，那 TLS 的 1 RTT 的握手时间还能继续优化吗？</p><p><img src="/images/决胜延迟的最后一公里/029.png" alt=""><br>答案是能，但这个 feature 目前还在 TLS 1.3 的草稿中。微信自己开发了一个 TLS 套件叫 MMTLS，也做到了 0 RTT。今天时间有限，我们就不在这里过多叙述了，有兴趣的同学可以自行查阅相关的资料。</p><p><img src="/images/决胜延迟的最后一公里/030.png" alt=""><br>这里我们刚才介绍了 TLS 会话的复用和 TLS False Start 选项。剩下的还可以优化证书链大小，最好是「站点证书 - 中间证书 - 根证书」三级，可以减少证书的大小，避免分包，还可以调整 TLS Record Size 和使用椭圆曲线加密算法的证书等等。<br>TLS 是一套很复杂加密的协议，还有很多的设置可以去调优，这里我就抛砖引玉先只详细介绍这么多。</p><p><img src="/images/决胜延迟的最后一公里/031.png" alt=""><br>我们接着看 HTTP/2。HTTP 2 没有改变 HTTP 协议的语义，但把底层传输机制全改了。<br>HTTP/2 采用二进制格式传输数据，而不是 HTTP/1.1 的文本格式，二进制格式在协议的解析和优化扩展上带来更多的优势。<br>所以 HTTP/2 对请求 Header 部分才好进行压缩传输。Header 的压缩是连接的两端共同维护了一份动态索引，当 Header 的 key value 出现一次后就能被索引和压缩。这样的话如果连接能一直保持复用，Header 中的重复 key 都能被压缩，非常好用。<br>多路复用就是所有的请求都是通过一个 TCP 连接并发完成。HTTP/1.1 虽然通过 Pipeline 也能并发请求，但是多个请求之间的响应会被阻塞的，所以 Pipeline 至今也没有被普及，而 HTTP/2 做到了真正的并发请求，同时还支持优先级。<br>HTTP/2 相对 HTTP/1.1 提升巨大，所以我们的相关域名有条件的话应该都尽量迁移到 HTTP/2。</p><p><img src="/images/决胜延迟的最后一公里/032.png" alt=""><br>前面我们总结了很多协议层上的优化要点，往往我们开了一堆优化选项才能优化下来一两个 RTT。但业务一不注意，Duang 十来个 RTT 就没了。这里上面我总结了几点，但其实核心意思都一样，尽量少传输数据。</p><p>今天的分享就是这些内容，PPT 中大量参考了 《High Performance Browser Networking》(译《 Web 性能权威指南》) 书中的内容，同时还引用了之前做的移动网络性能调研的一些数据，还有大量的知乎、维基百科等等资料，谢谢大家。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是 1 月 16 日在公司准备的一次技术分享的 PPT 和讲稿，考虑到 PPT 文件或者视频不容易被浏览引擎索引所以整理成一篇博客供大家参考。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/images/决胜延迟的最后一公里/0
      
    
    </summary>
    
    
      <category term="讲稿" scheme="https://faceair.me/tags/speech/"/>
    
      <category term="网络" scheme="https://faceair.me/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>2016 年终总结</title>
    <link href="https://faceair.me/2016/12/31/2016%20%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://faceair.me/2016/12/31/2016 年终总结/</id>
    <published>2016-12-31T03:25:00.000Z</published>
    <updated>2018-01-20T16:03:39.686Z</updated>
    
    <content type="html"><![CDATA[<p>去年 12 月收拾行李来到北京，到现在刚好一整年的样子。</p><p>刚到公司的时候是一边学习 Python 一边维护移动端 API 项目，主要是修修 Bug、加接口、调 RPC，还算游刃有余。慢慢熟悉了公司整体的技术架构以后开始独立负责或参与一些其他更有挑战的项目。</p><h4 id="值乎-amp-Live"><a href="#值乎-amp-Live" class="headerlink" title="值乎 &amp; Live"></a>值乎 &amp; Live</h4><p>比如开始给自己挖坑，重构了一把 wechat 项目，设计了一个复杂的插件化框架。将所有的功能模块全部独立开来，每个功能模块都是一个插件包，能方便新加和下线某个功能，还设计了一种依赖注入机制来解决插件间数据交换的问题等等等。</p><p>三月的 Hackathon 上值乎项目获奖后，决定要在愚人节的时候把值乎搞上线，可值乎后端是作为一个插件写在 wechat 项目里的。算起来 wechat 项目的插件加载方式和依赖比较奇怪，也不能很好地跟现有的测试框架兼容，只能把测试都注释了才能走通部署流程。然后因为用了比较多的面对对象的特性，导致抽象是够了但缓存不好加，访问量上去以后数据库扛不住，接口变得巨慢。而且也因为没有测试，本地只能跑起来简单看看，很多问题只能到线上才能发现。导致那天平台组都问我为什么我一直在上线，没好意思说我是在线上测试…</p><p>到后来公司开始重视值乎以后成立了专门的项目组，代码库也从 wechat 抽出来重写了，后续值乎项目我也没深度参与了。当然这些 wechat 设计上的坑我后来还是去填了一些，去掉了一些冗余的设计，换掉了 ORM，测试也全加上了，现在用起来问题不大了。</p><p>Live 项目也是三月尾开始的，工期也特别紧，要求项目能在五一上线。一个月出头的时间要求后端稳定下来，并跟客户端联调测试达到上线的要求，压力还是有点大。基本上四月一整个月都在加班，天天到凌晨回家，周末大部分时候也在加班，累惨了。不过总算是在四月尾勉强达到了上线测试的要求，然后将项目转交给同事就回学校准备毕业了。</p><p>加班太多了整个人都感觉不好，脑子整体混混沌沌的，也没法集中精力思考。每天起床就开始干活，到下班只想睡觉，什么都不想做。现在我对加班都有些阴影，不过好在除了那段时间项目赶工期，别的时候倒也没加过班了。</p><h4 id="移动网络优化-amp-消息推送"><a href="#移动网络优化-amp-消息推送" class="headerlink" title="移动网络优化 &amp; 消息推送"></a>移动网络优化 &amp; 消息推送</h4><p>到下半年正式入职以后我的职责又有些变化，更聚焦移动相关的技术了。</p><p>比如开始研究的就是移动网络优化，期望能在网络层面优化 App 的使用体验。我是野路子程序员，对网络协议的了解非常粗浅，这个时候就很明显地看到自己的短板了。好在领导也没给太多压力，给了我比较充足的时间去学习协议的细节，所以我花了很多时间来补 TCP、HTTP、HTTPS、HTTP2 等等相关的协议知识。关于针对移动网络的一些优化要点，之后有空的话再分享。</p><p>但仅仅了解还是不够，等最后测试并得到一些结论了以后，要想办法把想法和结论落地啊。我们打算构建一个跨平台的网络库来解决，最后打算将 Chromium 中的网络栈代码抽离出来打包成库给客户端使用，实际上<a href="http://www.infoq.com/cn/articles/mogujie-app-chromium-network-layer" target="_blank" rel="noopener">蘑菇街已经这样在做了</a>。说起来挺简单的，但整个过程对我而言非常痛苦，海量的 C++ 代码让我直接懵逼… 已经打算明年来补 C/C++ 和 Unix 下的网络编程了，希望明年能跟上节奏。</p><p>消息推送系统是另一个在做项目，为的是提升推送性能和灵活性。这个项目上我们花了非常多的时间来构思如何构建一个稳健、可拓展、松耦合的系统，这个时候思考的不仅仅是满足当前的需求了，难的是怎么去划分子模块和考虑满足未来可能会增加需求而不用动大的架构。这段时间我积攒了一些项目设计经验，以后遇到其他的设计需求时应该会轻松一些了。</p><h4 id="毕业了"><a href="#毕业了" class="headerlink" title="毕业了"></a>毕业了</h4><p>毕业流程走得非常顺利，写了份实习报告答辩完就毕业了。室友没到齐，班内也没组织散伙饭，拿到毕业证就各奔东西了。不过好像也没太多不舍和眷念什么的，大概因为早就知道和同学们不是一路人吧。从开始我就不太合群，很少参加班内的活动，也没特意去搞好寝室关系。大学四年也没认真上过课，上课多是去睡觉、玩手机或者看书，其他时间就自己折腾代码。这么想来，这几年时间倒也没荒废，总算是学了点东西。所以这个大学的意义就在于给了我充足的时间去自己学习吧，也挺好的。</p><p>大学中值得庆幸的事就是大二的时候进了番茄土豆团队吧，如果没有遇到他们，想不到我会混成什么样子。本来我挺彷徨的，对未来和学习都没有太多方向，两位老板、一尘大牛、精子和逸川给了我很多帮助，带我入门并给了我很多建议和指导，非常感谢！</p><h4 id="北京北京"><a href="#北京北京" class="headerlink" title="北京北京"></a>北京北京</h4><p>我租的房子刚好在北五环边上，从窗口看北京的夜景正好。刚到北京的时候我特别喜欢趴在窗口看外面的灯火、车流，那种感觉非常奇妙，甚至有种异样的不真实感。啊，我毕业了，我到北京了。</p><p>回想了一下今年的日子过得似乎很单调。一方面是实习工资少房租又太贵，还要攒学费、攒路费回学校等等，日子过得太紧吧，不敢出门。另一方面是每到节假日空气就开始变差，外面浓浓的雾霾简直不敢动，只敢开着空气净化器在家里蹲着打游戏。</p><p>明年打算空气好的时候多出去转转，出去骑骑车散散步，多运动运动减减身上长得肉，有空的话做做饭锻炼锻炼厨艺就更好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;去年 12 月收拾行李来到北京，到现在刚好一整年的样子。&lt;/p&gt;
&lt;p&gt;刚到公司的时候是一边学习 Python 一边维护移动端 API 项目，主要是修修 Bug、加接口、调 RPC，还算游刃有余。慢慢熟悉了公司整体的技术架构以后开始独立负责或参与一些其他更有挑战的项目。&lt;/
      
    
    </summary>
    
    
      <category term="总结" scheme="https://faceair.me/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>移动网络性能优化要点</title>
    <link href="https://faceair.me/2016/11/15/%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A6%81%E7%82%B9/"/>
    <id>https://faceair.me/2016/11/15/移动网络性能优化要点/</id>
    <published>2016-11-15T14:50:00.000Z</published>
    <updated>2018-01-20T16:03:39.691Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录一些非协议的常见优化要点，网络协议的相关优化以后有空再写。</p><p><strong>1. DNS</strong></p><p>问题：</p><ul><li>解析问题<ul><li>运营商劫持、域名失效</li><li>解析慢、失败</li></ul></li><li>单个 CDN 节点故障</li></ul><p>方案：</p><ul><li><p>解析问题</p><ul><li>HttpDNS</li><li>启动时下发服务器 IP 列表，类似 HttpDNS 的轮子</li></ul></li><li><p>单点故障</p><ul><li>根据权重选择合适的节点访问，即客户端应该获得服务端 IP 列表而不是单个 IP，部分现成的 HttpDNS 不支持 (比如 D+)</li></ul></li></ul><p><strong>2. 网络链路优化</strong></p><p>问题：</p><ul><li>移动网络链路冗长，延迟高</li><li>网络切换后原 IP 可能无法联通或慢</li></ul><p>方案：</p><ul><li>CDN</li><li>网络环境切换时及时刷新 DNS (HttpDNS)  缓存</li></ul><p><strong>3. 网络质量检测</strong></p><p>问题：</p><ul><li>2G/3G/4G/Wi-Fi 网络环境下延迟时间不一</li><li>同一网络环境中也可能有较大波动，比如在运行的地铁中</li><li>网络环境切换导致连接超时</li></ul><p>方案：</p><ul><li>根据用户的网络环境设置不同的超时参数（超时时间太短可能导致低速网络下无法建立连接，超时太长可能导致长时间等待）(携程)</li><li>根据请求状况动态调整请求策略 (Facebook)</li><li>客户端网络库检测网络环境切换状态，重新请求</li></ul><p><strong>4. 网络请求优先级和依赖机制</strong></p><p>问题：</p><ul><li>不同的网络环境下并发 TCP 连接的数量有限制 (待进一步确认，没找到可靠的消息来源)</li><li>短连接握手时间太长，都用短连接不合算</li></ul><p>方案：</p><ul><li>允许客户端在低速网络状况下一直保持长连接，减少 TCP 握手的时间</li><li>设定请求的优先级，重要的请求使用长连接，低优先级的用短连接，防止不重要的请求阻塞长连接队列</li><li>请求有依赖机制，当主请求失败后不再处理后续依赖的请求</li></ul><p><strong>5. 重试机制</strong></p><p>问题：</p><ul><li>快速失败给用户的体验不好</li></ul><p>方案：</p><ul><li>在幂等的请求(客户端决定)中可以启用重试策略</li></ul><p><strong>6. 减少数据传输量</strong></p><p>问题：</p><ul><li>数据包多传输时间长</li></ul><p>解决方案：</p><ul><li>启用 Gzip</li><li>采用更好的的序列化/反序列化方案</li><li>采用 WebP 图片格式</li></ul><p>参考:</p><ol><li>iOS应用架构谈 网络层设计方案 <a href="http://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html" target="_blank" rel="noopener">http://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html</a></li><li>R U Ok–客户端网络优化实践 <a href="http://2014.54chen.com/blog/2015/06/03/are-u-ok/" target="_blank" rel="noopener">http://2014.54chen.com/blog/2015/06/03/are-u-ok/</a></li><li>App的移动网络优化 <a href="http://www.xexplorer.net/index.php/archives/60/" target="_blank" rel="noopener">http://www.xexplorer.net/index.php/archives/60/</a></li><li>携程App的网络性能优化实践 <a href="http://www.infoq.com/cn/articles/how-ctrip-improves-app-networking-performance" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/how-ctrip-improves-app-networking-performance</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里记录一些非协议的常见优化要点，网络协议的相关优化以后有空再写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. DNS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解析问题&lt;ul&gt;
&lt;li&gt;运营商劫持、域名失效&lt;/li&gt;
&lt;li&gt;解析慢、失败&lt;/li&gt;
&lt;/u
      
    
    </summary>
    
    
      <category term="网络" scheme="https://faceair.me/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>2015 年终总结</title>
    <link href="https://faceair.me/2016/02/09/2015%20%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://faceair.me/2016/02/09/2015 年终总结/</id>
    <published>2016-02-08T16:00:00.000Z</published>
    <updated>2018-01-21T06:06:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>年初的时候还在对 helpful 修修补补，添加手机页面支持、国际化、附件上传和邮件订阅的相关工作。这个时候的我已经会用各种库来实现想要的功能了，对项目的整体架构有了一些认识，能按功能来划分模块，但对面对对象编程的理解还不够透彻。虽然我将 mongoose 作为 ORM 库来使用，但并没有彻底的理解 ORM 的好处。我曾一度不理解 mongoose 返回的 document 除了给人添堵、不能直接取键值以外到底有什么用，对数据的操作全部是用 collection model 上自带的方法完成的。感觉异常的别扭，但又不知道哪里不对劲。</p><p>直到三月中下旬开始接手重构 cashier 项目，看到代码里面通过 sequelize 实现的对表的抽象和对数据的抽象感觉打开了一道大门。原来 ORM 提供的是数据的抽象，每个数据实例不单单包含数据内容信息还包括了你期望的这个实例所具有的所有功能，比如一个文章的实例可以自带取作者信息和更新标题的方法。这个数据实例可以在不同模块直接传递，也可以直接调用数据实例上的方法，这样用简直太方便了，代码看起来清晰也容易理解。</p><p>cashier 是一个订单管理系统，毕竟跟钱相关需要对数据的可靠性做出保证，所以引入了数据库外键和事务。通过 sequelize 来定义表的关联，数据实例也很容易拿到它的关联数据。虽然是第一次使用事务，但我之前对事务略有耳闻知道是怎么回事。事务一般是将一组 SQL 串行执行，每条语句会带有操作条件，如果其中某个语句执行失败，所有的操作都会回滚。如果在执行事务的过程中程序 crash，事务最终没有被 commit，那这个事务所做的修改也不会被持久化。这样在断电或、程序 crash 等极端情况下或者并发操作同一条记录的情况下都能保证数据的一致和可靠性。</p><p>之前我一直是用 <a href="https://github.com/caolan/async" target="_blank" rel="noopener">async</a> 来搞定流程控制上的问题，没有什么问题，但是用的越多越感觉 callback 在处理 error 的时候实在太繁琐，几乎每个回调函数的首行都是 <code>if(err){callback(err)}</code> ，这样将错误一层一层往上抛，最后被调用者获取并处理。当不同的模块间相互调用太多的时候，错误处理就变得很麻烦。后来在 @jysperm 的影响下开始调研在 cashier 中用 Promise 来处理所有的异步流程，Promise 带来的好处就是统一了回调和错误处理流程。Promise 理解起来并不复杂，每个异步任务都返回一个 Promise 对象，这个对象有三种状态 <code>Pending</code>、<code>Fulfilled</code>、<code>Rejected</code>，then 方法接收回调函数和错误处理回调，catch 方法接收错误处理回调，Promise 可以链式执行，也就避免了回调地狱，代码看起来会清晰很多。</p><p>现在遇到的一个问题是是在 Promise 链式调用中无法中断执行流程，只能抛出一个特殊的异常来中断，感觉还是有点别扭。另一个问题是 node.js 标准库还没有支持 Promise，需要自己封装一遍，不过现在社区也在讨论<a href="https://github.com/nodejs/node/pull/5020" target="_blank" rel="noopener">将标准模块 Promise 化</a>的相关事情了。还值得注意的是 <a href="https://github.com/ysmood/yaku#compare-to-other-promise-libs" target="_blank" rel="noopener">Promise 不同的实现在性能上有比较大的差别</a>，可能换个 Promise 类库就能让你的程序速度快几倍。</p><p>当订单完成的时候需要给接入的网站发送异步通知和给用户发送订购邮件。这些异步任务的执行时长不定，很容易导致任务堆积和积压，如果执行失败要在合适的时间重试，如果重试失败也要通知开发者。如果不用队列的来处理，单独处理每个任务会很繁琐，也无法简单地横向拓展。最后根据 @orzfly 的建议最后选用了 resque 在 node.js 中的实现 <a href="https://github.com/taskrabbit/node-resque" target="_blank" rel="noopener">node-resque</a>，并通过 <a href="https://github.com/resque/resque-web" target="_blank" rel="noopener">resque-web</a> 来查看和管理异步任务。</p><p>五六月的时候梳理了 JavaScript 的原型继承相关概念，调研了 <a href="/2015/06/03/%E6%8B%92%E7%BB%9D%E5%A4%96%E9%83%A8%E4%BF%AE%E6%94%B9%E7%9A%84%E5%AF%B9%E8%B1%A1/">mongoose 里面的一些黑魔法</a>，为了实践一下还写了一个简易的 ORM 原型 <a href="https://github.com/faceair/cado" target="_blank" rel="noopener">cado</a>。ES6 中添加了 class 关键字作为构造函数的语法糖，比较像 CoffeeScript 了。</p><p>下半年大部分时间是花在了另一个项目 pomotodo-node 上了。项目虽说大一点，但是因为都模块化了所以整体的复杂度也没有很高，所用到的技术跟 cashier 差不太多，也没太多值得说的。</p><p>这一整年我都对网络相关很感兴趣，写了两个小东西 <a href="https://github.com/faceair/lyssa" target="_blank" rel="noopener">lyssa</a>、<a href="https://github.com/faceair/PowerProxy" target="_blank" rel="noopener">PowerProxy</a>。PowerProxy 是参考 <a href="https://itunes.apple.com/us/app/surge-web-developer-tool-proxy/id1040100637" target="_blank" rel="noopener">Surge</a> 和 <a href="http://anyproxy.io/cn/" target="_blank" rel="noopener">anyproxy</a> 实现的网络调试工具，主体是一个 HTTP Proxy Server ，通过中间人攻击 (自制证书) 方法注入 HTTPS 来嗅探所有请求，打算采用 <a href="http://electron.atom.io/" target="_blank" rel="noopener">electron</a> 制作跨平台应用。现在思路不是特别清晰，如果能把思路理顺应该会继续。</p><hr><p>考虑到五一黄金周人山人海，专门挑了五一前几天跟女朋友去庐山玩了一趟。蜿蜒曲折的山路、险峰，确实也别有一番风味。我们去的时候没有看到山雾，听导游说前几天都有的，总之是错过了。</p><p>本来我是不想学驾照的，我对无人驾驶汽车的未来还是很有信心的，人的反应速度和操作能力终归是比不上电脑的。不过依旧是没有拗过，暑假的时候在家里的一再劝说下开始考驾照，暑假学了有一个多月再加上后来又补考了科目三，最后在十一月的时候拿到了驾照。</p><p>我们大四有两门选修课，我学分差不多实在不想继续呆学校了，室友同学也开始出去找实习。我就搬到校外跟女朋友租房子住，开始了一起买菜做饭的日子，经过几个月的练习，现在我也能差不多做一些菜了。之前在学校经常是凌晨三四点睡觉的，现在也开始纠正自己的作息习惯了。这样远程工作的日子还是挺舒心的，每天睡到自然醒然后起床吃点东西干点活，有时候跟朋友一起开开黑打游戏，不用打卡不用朝九晚五。</p><p>十一月尾的时候 @顾惜朝 姐姐在知乎私信上问我想不想去知乎实习，我的天然后我后来居然就顺利通过了面试，在年底的时候像做梦一样就来到了北京。除了空气，北京的一切都还不错，在北京的具体生活我以后再写吧。</p><hr><p>感觉这一年像是分水岭，终于离开了学校，开始了新的生活。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;年初的时候还在对 helpful 修修补补，添加手机页面支持、国际化、附件上传和邮件订阅的相关工作。这个时候的我已经会用各种库来实现想要的功能了，对项目的整体架构有了一些认识，能按功能来划分模块，但对面对对象编程的理解还不够透彻。虽然我将 mongoose 作为 ORM 库
      
    
    </summary>
    
    
      <category term="总结" scheme="https://faceair.me/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>拒绝外部修改的对象</title>
    <link href="https://faceair.me/2015/06/03/%E6%8B%92%E7%BB%9D%E5%A4%96%E9%83%A8%E4%BF%AE%E6%94%B9%E7%9A%84%E5%AF%B9%E8%B1%A1/"/>
    <id>https://faceair.me/2015/06/03/拒绝外部修改的对象/</id>
    <published>2015-06-02T20:41:00.000Z</published>
    <updated>2018-01-21T06:09:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>document</code> 是 mongoose 的数据实例，它拥有一些比较有意思的特性</p><ol><li>实例拥有一些方法，能被正常调用</li><li><code>console.log</code> 显示的是纯数据，不包含方法</li><li>实例属性可以内部增加，但不能在外部增加</li><li>实例属性在外部不可被覆写，也不能被删除</li><li>实例在执行 <code>update</code> 方法后，属性也能被更新</li></ol><p>看起来，1 和 2 比较冲突，3、4 和 5 也比较冲突。所以要怎么实现呢？</p><p>1、2 实现看起来比较简单，最简单的是把方法都添加到实例创建的原型上，这样创建的 <code>document</code> 实例的时候会自动继承原型上的方法，而在 <code>console.log</code> 实例的时候不会显示继承的属性，所以显示的结果会看起来非常干净。</p><p>后面的 3、4、5 统称起来就是 <strong>实例可内部修改但不能被外部修改</strong> ，这个实现起来就麻烦了。</p><p>创建一个<strong>不可被修改也不能被删除</strong>的对象非常地容易，将 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty</a> 中的 <code>configurable</code> 和 <code>writable</code> 都设为 <code>false</code> 就可以了。但是这样创建的对象是完全不能被修改的，更新属性的话没法搞。<br>要支持更新属性也行啊，把 <code>configurable</code> 和 <code>writable</code> 都设为 <code>true</code> … orz，这样就能外部修改了。</p><p>还有个办法就是用 <code>getter</code>，听起来不错，但是实际使用的时候发现 <code>configurable</code> 不能设为 <code>false</code>，不然的话不能更新 <code>getter</code> 里面的数据，设为 <code>true</code> 以后数据虽然不能被更新但又能被删除。<br>而且，设置了 <code>getter</code> 以后，用 <code>console.log</code> 打印实例的时候属性会显示成 <code>[Getter]</code>，而不是实际值，这样跟 2 又冲突了。</p><p>还有个办法 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal" target="_blank" rel="noopener">Object.seal</a> 可以密封对象。<strong>被密封后的对象不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可以修改已有属性的值的对象</strong>。orz … 这里的修改并不能限制外部的。</p><p>似乎可以综合一下，<code>Object.seal</code> 允许修改，<code>getter</code> 可以限制修改来源。</p><p>而实际上 <code>getter</code> 的数据更新可以指定到一个内部变量，这样只用更改这个变量就可以更改这个属性了，而不用去直接改 <code>getter</code>，类似于做了一个映射。</p><pre><code>class Model  constructor: (record) -&gt;    _.extend @, record: record    _.keys(record).map (key) =&gt;      Object.defineProperty @, key,        enumerable: true        configurable: false        get: -&gt;          @record[key]  update: (record) -&gt;    _.extend @, record: record</code></pre><p>这样处理的话已经成功了一部分了，再还要不允许往实例上添加属性，在构造函数里面加上 <code>Object.seal @</code> 就好了。</p><p>后面的问题处理完了，但是前面的 1、2 又冲突了。添加的 <code>record</code> 属性会在 <code>console.log</code> 的时候显示出来，而添加的 <code>getter</code> 也会显示成了 <code>[Getter]</code>。</p><p>去研究了下 mongoose 的实现，发现它在 <code>document</code> 的原型里面添加了一个 <a href="https://github.com/Automattic/mongoose/blob/8be119d1e240bd1004972d10da3f110a6f899b59/lib/document.js#L1915" target="_blank" rel="noopener">inspect</a> 方法。<br>我和逸川一起追溯了一下 <a href="https://github.com/joyent/node/blob/master/lib/console.js#L57" target="_blank" rel="noopener">console.log</a> 的在 node.js 中的实现，整个的流程就是</p><ul><li><code>console.log</code> 调用了 <code>util.format</code></li><li>然后进而调用了 <code>util.inspect</code></li><li><code>util.inspect</code> 又调用了 <code>formatValue</code></li><li>然后是 <code>formatValue</code> 调用了传入 <code>console.log</code> 的参数的 <code>inspect</code> 方法</li></ul><p>所以，<strong><code>console.log</code> 的传入参数的 <code>inspect</code> 方法会直接影响 <code>console.log</code> 显示的内容</strong>。</p><pre><code>class Display  constructor: -&gt;  inspect: -&gt;    return &apos;hello&apos;console.log new Display()  # 会显示 hello</code></pre><p>那我们再给我们的 Model 加上 <code>inspect</code> 方法，里面返回 <code>record</code> 的数据即可。</p><p>这样我们就实现了一个 <strong>可内部修改但不能被外部修改</strong> 的对象了。</p><p>完整的示例参见 <a href="https://github.com/faceair/cado" target="_blank" rel="noopener">cado</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;document&lt;/code&gt; 是 mongoose 的数据实例，它拥有一些比较有意思的特性&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实例拥有一些方法，能被正常调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;console.log&lt;/code&gt; 显示的是纯数据，不包含方法&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://faceair.me/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Hour of code 讲稿</title>
    <link href="https://faceair.me/2015/05/13/Hour%20of%20code%20%E8%AE%B2%E7%A8%BF/"/>
    <id>https://faceair.me/2015/05/13/Hour of code 讲稿/</id>
    <published>2015-05-12T16:00:00.000Z</published>
    <updated>2018-01-21T06:06:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是5月7日图书馆 <code>Hour of code</code> 活动的讲稿。讲稿大量参考了<a href="https://jysperm.me/" target="_blank" rel="noopener">精子的博客</a>，感谢~</p></blockquote><p>各位学弟学妹好，我叫熊豹。现在大三，是建筑系土木工程专业的学生，同时也在一家互联网创业公司里面远程实习。<br>非常高兴能在这里跟大家分享一些经验和想法，希望能对你们有所帮助。</p><p>我开始接触编程的时间不算太早，高三左右开始写代码，到现在差不多四五年的样子。<br>现在主力语言 Node.js，以前用过一段时间 PHP，加起来写了十几万行的代码。<br>独立完成过一些大大小小的项目，写过 web 框架、DNS 服务器、反向代理、网盘、验证码识别、爬虫等等。<br>你们应该都有用我们学校的微信公众号查分吧？那个也是我写的。<br>接触的东西不少，也踩了了很多坑，走了很多弯路。</p><hr><h2 id="观念"><a href="#观念" class="headerlink" title="观念"></a>观念</h2><p>在座的各位在学习编程的时候，我希望大家能先树立这样一些观念：</p><ol><li><p>接入世界性互联网</p><p>因为一些总所周知的原因，我们并不能自由地浏览一些网站。而我们在查找资料的时候，这将给我们带来非常大的困扰。<br>你可以找人要个 VPN 或者尝试使用 GoAgent，或者选择购买曲径、GreenShadow。</p></li><li><p>版权意识</p><p>你要认识到，如果你打算在计算机领域进行一些创造，那么维护版权，就是在维护你自己将来的利益，请试着去影响身边的更多人。<br>可能你因为种种原因无法购买正版软件，但至少请认识到这是对作者利益的一种损害。</p></li><li><p>从官方渠道下载文件，获取信息</p><p>也许是因为一直用盗版，很多人没有养成从官网下载软件的习惯，出了问题也想不到去求助官方客服。<br>很多人查找资料不喜欢去官网，而喜欢看个人博客或总结，这样在信息的传递过程中可能会出现偏差。或者原作者对官方的文档做了一些更正而你的信息来源没有及时更正，也可能造成一些误差。</p><p>不管你信不信，这是避免出现问题，解决问题的最方便，有效的手段。<br>毫无疑问从官网得到的信息是最权威的，这在解决问题和与别人辩论的时候都很有用。</p></li><li><p>扔掉旧东西</p><p>扔掉那些旧的，官方已经不再推荐或提供支持的东西，比如 IE6, WinXP, VC++6.0, VB6..<br>一定会有新的更好用的替代品的，如果没有的话可以考虑自己创造一个。</p></li><li><p>使用 Google</p><p>Google 会让官网出现在第一个，跟上上条观点相承，官方渠道更值得信赖。<br>Google 会包含英文的搜索结果，这个时候不要害怕不要怂，即使你不懂英文，但很多问题只需一句话，一个词就能解决，你能搞定的。</p></li><li><p>学会Debug</p><p>当你程序出BUG的时候最重要的是报错信息，读懂它将对你解决问题非常有帮助。你可以直接搜索报错信息，或者简要描述你的问题再搜索。有时候并不能搜到合适的结果，可以尝试用英文描述下你的问题再搜索。<br>你用到的可能是一个再 Github 上的开源组件，这时候去搜一下它的 issues 可能会有所收获。如果找不到相关 issues，那你可以考虑去阅读你所用的开源组件的代码，断点调试一下。</p></li><li><p>学会提问</p><p>如果无法通过搜索解决问题时，那么就需要去社区提问，在此之前你有必要学习一下提问的智慧。如果是 Github 上的开源项目，可以直接新开一个 issue。<br>尽量不要在 QQ 或邮件上单独向别人提问，尤其是搜索就能解决的问题，因为这样的话，别人无法搜索到你最后解决问题的经验，而且对方欢迎不欢迎你的提问还说不定。</p></li><li><p>多阅读</p><p>无论是在网上还是图书馆，你都应该在你研究的领域多读一些书和文章。书籍的内容是经过精心的安排的，它的目标就是供人阅读。<br>不一定什么时候就会派上用场，你可能记不住文章的所有内容，但只需记住几个关键词，在要用到的时候你就可以重新找到这篇文章。</p></li><li><p>将自己的作品展示给大家看</p><p>如果仅仅是练习的作品，没有什么商业机密，自己藏着不如发出来给大家看。你可以到 Github 上开源自己的代码，也给更多后来的人一些参考。</p><p>同时对你自己也是一种压力，因为要展示给大家，所以你要让作品尽可能完美，不给自己丢脸。你也可以去参考代码质量较高开源项目不断完善自己的项目。一步一个脚印，也是自己成长的见证。<br>如果你的业余项目代码质量很高，对你将来找工作也是一种帮助。</p></li></ol><hr><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>我现在所想讲的不仅仅是编程，包括整个计算机和互联网领域。</p><p>现在互联网进入我们的生活，遍布世界的每一个角落，连接着世界上几十亿的设备，能让任何人在半秒之内，联结世界上任意两点。<br>当你在 QQ 上发出一条消息时，它会在光纤中穿过大半个中国，经过十几个路由的转发，调用若干台服务器，最后在不到一秒内被对方看到。</p><p>计算机和互联网可以算是由全人类共同构建的，最精密也是最庞大的工程。<br>每一个芯片都是在纳米级被雕刻而成的，容不得哪怕一粒灰尘的差错。<br>无数黑客、恐怖分子对互联网虎视眈眈，但它仍健壮地运作，支撑着整个世界的信息传递。</p><p>计算机还是一个几乎全新的学科，仅 60 年历史，而互联网更是仅仅 30 年。<br>硬件在以摩尔定律预测的那样每年翻一番，而软件方面也在不断更新迭代，没人知道计算机领域今后会发展成怎样。<br>相比于已经十分稳定的学科，计算机还在快速发展，有更多的变数，也有着更多可能取得突破的机会。</p><p>而我们就处在这样一个机遇与挑战并存的时代，一不小心就会被急剧发展的时代所抛弃。<br>为了跟上发展脚步，我们只有不断地学习，扔掉旧的过时的知识，拥抱新的变化。</p><p>现在老师在课堂上教的东西，可能是过去四五年流行过的工具或者语言，现在可能已经有了更好地东西来替代或者已经被替代好几代了。</p><p>我举个简单的例子，前端开发。</p><p>我之前上过几次我们学校的课，课堂上还停留在table布局的层次上。而现在你们知道前沿的前端发展成什么样子了吗？</p><p>div 布局？你们啊，还是 too young。</p><p>这几年浏览器大换血，Chrome 一统江湖(包括含 Chromium 内核的国产双核浏览器)，新的 V8 引擎大幅度提高了前端 JavaScript 的运行效率。<br>前端中 JavaScript 占的比重也越来越大，之前还只是 JavaScript 作为辅助页面的交互语言存在，而现在则完全成了前端的主角。<br>甚至前端逐渐跟后端分离开来，也不需要后端来渲染页面，而只用提供数据，由 JavaScript 来完成渲染。</p><p>随着大家对审美和用户体验的要求越来越高，每个页面单独渲染的模式已经无法满足日益增长的需求了。<br>如果点个赞要刷新一次网页，打开评论要打开新的网页，关注一个人要打开一个新的网页，这样的交互你受得了么？</p><p>前端现在也发展出了 MVC、MVVM 等等概念，也出现了大量的 JavaScript 框架比如 angularjs、avalon、backbone、React 等等，甚至可以写独立应用。<br>有心的同学可以回去打开新浪微博首页的源代码看看，主体部分除了 script 标签以外已经没有其他标签了。<br>我们公司的产品番茄土豆的也是完全的前后端分离的典范。(<strong>插播一条广告，番茄土豆是番茄工作法和 todo list 结合一个效率类软件，客户端全平台覆盖，有兴趣的同学可以试用一下</strong>)<br>手机上的淘宝、美团外卖、知乎和手机 QQ 部分页面也都使用了前端技术构建。</p><p>这些都是近两年发生的变化。</p><p>我前面说了很多变化，那么我们的学习中就没有什么是不变的么？<br>当然也不是，程序是算法+数据结构，这些都是基本功。基本功还包括计算机原理、计算机网络、编译原理等等。<br>一般基础打好，学习新的东西也会很快，不用太过于担心。</p><p>我这里只是提醒你们知识是学不完的，技术也在不断地进化，要时刻保持学习的心态。</p><hr><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p>接下来一部分我想讲一讲 Node.js。</p><p>Nodejs 自从 2009 年发布，因其出色的性能和开放的姿态一直备受关注。</p><p>阿里巴巴是应该是国内最先大规模使用 Node.js 的公司，在 2011 年的时候就开始在淘宝指数、数据魔方以及淘宝时光机等栏目上开始使用。<br>而在去年淘宝开始实时前后端分离计划，Node.js 作为数据中间层占了一个很重要的地位。现在我的淘宝、淘宝收藏夹、商品详情页、天猫首页、天猫会员、天猫电器城已经在使用 Node.js 了，未来还会有更多业务会迁移到 Node.js 上面。</p><p>除了淘宝以外，还有百度、网易以及一些创业公司比如知乎、teambition、花瓣网、番茄土豆(我司)在尝试用 Node.js 构建他们的产品。</p><p>听到到 Node.js 这个名字，初学者可能会误以为这是一个 JavaScript 应用。事实上， Node.js 采用 C++ 编写而成，是一个 JavaScript 的运行环境。</p><p>为什么采用C++语言呢？据 Node.js 创始人 Ryan Dahl 回忆，他最初希望采用 Ruby 来写 Node.js，但是后来发现 Ruby 虚拟机的性能不能满足他的要求，后来他尝试采用 V8 引擎，所以选择了 C++。</p><p>既然不是 JavaScript 应用，为何叫 .js 呢？因为 Node.js 是一个 JavaScript 的运行环境。提到 JavaScript，大家首先想到的是日常使用的浏览器，现代浏览器包含了各种组件，包括渲染引擎、JavaScript 引擎等，其中 JavaScript 引擎负责解释执行网页中的 JavaScript 代码。</p><p>作为 Web 前端最重要的语言之一，JavaScript 一直是前端工程师的专利。不过，Node.js 是一个后端的 JavaScript 运行环境（支持的系统包括 *unix、Windows），这意味着你可以编写系统级或者服务器端的 JavaScript 代码，交给 Node.js 来解释执行。</p><p>Node.js 采用了 Google Chrome 浏览器的 V8 引擎，性能很好，同时还提供了很多系统级的 API ，如文件操作、网络编程等。浏览器端的 JavaScript 代码在运行时会受到各种安全性的限制，对客户系统的操作有限。相比之下，Node.js 则是一个全面的后台运行环境，为 JavaScript 提供了其他语言能够实现的许多功能。</p><p>Node.js 的设计思想中以事件驱动为核心，它提供的绝大多数 API 都是基于事件的、异步的风格。以 Net 模块为例，其中的 net.Socket 对象就有以下事件：connect、data、end、timeout、error、close 等，使用 Node.js 的开发人员需要根据自己的业务逻辑注册相应的回调函数。这些回调函数都是异步执行的，这意味着虽然在代码结构中，这些函数看似是依次注册的，但是它们并不依赖于自身出现的顺序，而是等待相应的事件触发。</p><p>事件驱动、异步编程的设计，重要的优势在于，充分利用了系统资源，执行代码无须阻塞等待某种操作完成，有限的资源可以用于其他的任务。此类设计非常适合于后端的网络服务编程，Node.js 的目标也在于此。在服务器开发中，并发的请求处理是个大问题，阻塞式的函数会导致资源浪费和时间延迟。通过事件注册、异步函数，开发人员可以提高资源的利用率，性能也会改善。</p><p>Node.js 在设计上也是比较大胆，它以单进程、单线程模式运行，这和 JavaScript 的运行方式一致，事件驱动机制是 Node.js 通过内部单线程高效率地维护事件循环队列来实现的，没有多线程的资源占用和上下文切换，这意味着面对大规模的 http 请求，Node.js 凭借事件驱动搞定一切。</p><p>性能是 Node.js 的优势之一，还有一个很重要的优势是强大的社区支持，大家都非常愿意分享自己的代码和知识经验。</p><p>NPM 是 Node.js 的包管理器，这里我说的包是指别人封装好的独立的模块。<br>NPM 平台上的第三方模块超过 14W，在去年6月超越 Maven Central (Java) 和 gem (ruby) 成为了最大的包管理平台，这两个平台上的的模块数量现在刚过 10W 大关，还有一些其他语言的包管理器，比如 PHP、.Net、Go 上面的包都远不到 10W。<br>除了包的数量以外，包的下载量更是惊人，现在每天NPM平台上的下载量就有几千万，每个月更是有十几亿的下载量。</p><p>一般的 Node.js 项目都会依赖几个或者几十个第三方模块，大大降低了重复劳动，提高了工作效率。<br>而你在开发的过程中，有一些很好的封装也可以很简单得发布出来，回馈社区方便他人。</p><p>Node.js 现在发展势头正猛，有兴趣的同学可以回去自己再查查相关资料。</p><p>参考:</p><ul><li><a href="https://jysperm.me/2013/02/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8DGeek/" target="_blank" rel="noopener">如何成为一名Geek</a></li><li><a href="https://jysperm.me/2013/06/1110/" target="_blank" rel="noopener">编程之美</a></li><li><a href="http://www.infoq.com/cn/articles/what-is-nodejs" target="_blank" rel="noopener">深入浅出Node.js（一）：什么是Node.js</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是5月7日图书馆 &lt;code&gt;Hour of code&lt;/code&gt; 活动的讲稿。讲稿大量参考了&lt;a href=&quot;https://jysperm.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;精子的博客&lt;/a&gt;，感谢~&lt;
      
    
    </summary>
    
    
      <category term="讲稿" scheme="https://faceair.me/tags/speech/"/>
    
  </entry>
  
  <entry>
    <title>2014 年终总结</title>
    <link href="https://faceair.me/2014/12/31/2014%20%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://faceair.me/2014/12/31/2014 年终总结/</id>
    <published>2014-12-30T16:00:00.000Z</published>
    <updated>2018-01-21T06:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>好快，今天已然又是这一年的最后一天，回首这一年还是感觉收获颇丰。</p><p>年初的前两个月还在懵懵懂懂地学 PHP 框架，虽然对网站有一些理解，但需求稍微复杂一点就有心无力了。这段时间过得比较蛋疼，期间学了些设计模式、还有一些前端框架的使用，有个二手市场的项目做了一半烂掉了。<br>四月份的时候参加了一个学校的网络新媒体班，如果顺利结业的话貌似是有一个辅修证书，然后有一大堆学分。本来是怕挂科太多毕不了业，打算去混学分来着，后来因为的确太费时间，上了两个月课放弃了。<br>五月份的时候由黄埔学长带我去百度校园极客大赛打了个酱油，这是我第一次去北京，之前甚至没有出过省。在北京逛了一圈，感觉北京的公共交通还是很发达的，地铁线路比武汉多得多，而且没有武汉挤。再别的也没啥特别的了，好像城市一大就会变得千篇一律。</p><p>因为之前暑假、寒假在家过得很不愉快，老是被嫌弃。家里人也无法理解我在做的事情，矛盾冲突不断，所以决定暑假的时候无论如何都不能在家待了。也可以说是一种逃离。<br>等到四五月份的时候我就在找暑期工作了，先给好几个武汉的公司投了简历，有的没有明确答复、有的直接拒绝、有的杳无音信，这时才感觉自己还是太弱。幸运的是后来在 <a href="http://www.v2ex.com/t/112797" target="_blank" rel="noopener">V2EX</a> 发帖找到了一份<a href="https://pomotodo.com/" target="_blank" rel="noopener">番茄土豆</a>的实习，不过却不是 PHP 。</p><p>我是进入公司以后才开始学 Node.js 的，老板说相信我能很快学会。。。然后给了我一个新项目的后端让我负责，现在想想他们还是胆子很大啊。之前我用 PHP 都没写过这么完整的项目，而且 Node.js 也是初学，很多地方都不清楚。我已经记不清我自己是怎么一点一点梳理需求，然后一点一点搞定的了。期间踩过很多坑，代码重构过无数遍，进度慢得一塌糊涂，好在他们没有给我太多时间上的压力。<br>这边的生活比较惬意，我们在昆山的一个小别墅里面办公，人不多所以也没有打卡什么的，时间安排很自由。那时候我一般中午十二点左右起床吃饭，然后晚上十二点睡觉。别的时候写代码或者开黑打 LOL ，或者跟妹子去上海和苏州玩、看电影(小区里就有电影院！)。他们有 PS4 ，配一个大液晶显示屏，玩起来效果很好，不过我太会操作所以玩得也很少。<br>等到大三开学课也越来越少，所以实习到现在也还在继续。</p><p>跟他们厮混了一段时间，他们的一些思想和行为也在影响我，我现在说话的感觉越来越像我们老板了。。。而且因为现在有了工资，我的消费观念也发生了一些改变。我认识到我的时间是有价值的，能花费很少的钱就能搞定的事就不要浪费太多时间。导致的结果就是花钱越来越大手大脚了。。。<br>下半年换掉了之前的小米手机，换成了 iPhone 5c 。现在用了几个月还是很满意的，应用质量比较高，也都流氓不起来。这样我就少了很多时间在折腾手机本身上了，以前每隔几天就要刷个机不然没法用。<br>还把笔记本换成了 MacBook Air ，做工不错，屏幕效果也比我之前的电脑好，键盘和触摸板也很好用。现在开始晚上拉闸限电，它续航时间挺长，熄灯以后亮度调低一点可以撑到第二天来电。而且少了很多时间在折腾黑苹果上了，之前笔记本 WIFI 后来老是坏实在太烦。</p><p>我对我们学校的微信还是有很深的感情的，毕竟我之前在上面花了很多时间。也怕以后没人接手被荒废了，所以这学期我在大学生网络中心里面建了个编程小组，收了几个大一的小徒弟来教 Node.js ，花了一些时间不过进度还是很慢，前几天才又拉了 @jamlee 加入进来。<br>现在还在对微信接口用 Node.js 做重构，做了一些性能上的优化，前端框架也换了，支持了自定义菜单，预计期末之前这个版本能上线。明年应该还会继续完善。</p><p>现在跟妹子的感情越来越好了，么么哒~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好快，今天已然又是这一年的最后一天，回首这一年还是感觉收获颇丰。&lt;/p&gt;
&lt;p&gt;年初的前两个月还在懵懵懂懂地学 PHP 框架，虽然对网站有一些理解，但需求稍微复杂一点就有心无力了。这段时间过得比较蛋疼，期间学了些设计模式、还有一些前端框架的使用，有个二手市场的项目做了一半烂
      
    
    </summary>
    
    
      <category term="总结" scheme="https://faceair.me/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>理解 Node.js 异步编程</title>
    <link href="https://faceair.me/2014/09/15/%E7%90%86%E8%A7%A3%20Node.js%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>https://faceair.me/2014/09/15/理解 Node.js 异步编程/</id>
    <published>2014-09-14T16:00:00.000Z</published>
    <updated>2018-01-21T06:07:00.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h2><p>JavaScript 是单线程设计，任务的调度方式就是队列。即在运行过程中只有一个线程在运行，也就是说每次只能执行一个任务。当调用 <code>setTimeout</code> 这种异步函数的时候，会将控制权交给通信线程，其中的回调不会立即执行。而当调用赋值等同步语句的时候，会立即执行。JavaScript 虚拟机会轮询这个队列，执行合适的事件。</p><p>这样做有什么好处呢？</p><p>不用新开线程，减轻系统开销，再多的并发也只是加长了事件队列，也不会令执行混乱。</p><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p>一般同步执行的的 Web 程序中操作 IO 的函数总是执行时间最长的，当网络和存储技术不发生大的革新的情况下，异步IO 是一个提升响应速度的好办法。</p><p>同步IO 就是在执行 IO 操作的时候线程阻塞，不继续向下执行，而是一直等待这个 IO 操作的返回。 而当 JavaScript 虚拟机调用了异步IO函数以后，不会等待函数的返回，而是继续执行下一个事件。</p><p>那什么怎么知道异步函数执行完了呢？</p><p>IO 操作是另外的通信线程来实现的，通信线程操作结束后会将执行原始回调函数的引用加入到 JavaScript 事件队列中，JavaScript 虚拟机因为一直在轮询这个事件队列，会发现这个事件并完成后续的处理。对于 Node.js 应用而言，它是部分多线程，即非阻塞IO 为多线程，但是 IO 结果的处理还是单线程执行。</p><p>所以 Node.js 的执行过程能保证非常的迅速。</p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调函数也是一个函数，只不过它的调用方式跟普通的函数不一样，它是由事件驱动的。比如完成个某个IO 操作以后执行回调，那么这个回调这是由完成事件来触发的。</p><p>人脑最自然的思考方式是顺序执行，非常适合写同步代码。而异步理解起来会比较绕，你需要将下一个执行的事件封装成一个回调函数，然后当一个参数传递给异步函数。异步函数在完成它自己的操作以后再执行这个回调函数，而这个回调函数里面又可能有其他异步函数，里面也有回调函数，所以整个执行过程看起来会比较像一个金字塔。</p><p>比较合理的做法是将不同的回调封装成函数，在异步函数里面只做调用，这样代码的结构会清晰很多。但有时候还是会造成一些混乱，所以也有 <a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">Q</a> 和 <a href="https://github.com/caolan/async" target="_blank" rel="noopener">async</a> 这些来填坑的库。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;事件队列&quot;&gt;&lt;a href=&quot;#事件队列&quot; class=&quot;headerlink&quot; title=&quot;事件队列&quot;&gt;&lt;/a&gt;事件队列&lt;/h2&gt;&lt;p&gt;JavaScript 是单线程设计，任务的调度方式就是队列。即在运行过程中只有一个线程在运行，也就是说每次只能执行一个任务。
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://faceair.me/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>解决 elementory os 频繁卡死</title>
    <link href="https://faceair.me/2014/02/28/%E8%A7%A3%E5%86%B3%20elementory%20os%20%E9%A2%91%E7%B9%81%E5%8D%A1%E6%AD%BB/"/>
    <id>https://faceair.me/2014/02/28/解决 elementory os 频繁卡死/</id>
    <published>2014-02-27T16:00:00.000Z</published>
    <updated>2019-04-19T16:21:29.029Z</updated>
    
    <content type="html"><![CDATA[<p>真是被折腾死了，要看解决办法请直接跳到结尾。。</p><p>年前的时候eos就是这样频繁卡死，tty调不出来，鼠标界面卡住不动。自己又找不到啥原因，最后干脆卸载了eos，转战其他发行版。期间因为不知道u盘有问题，换了N个发行版装了几十遍都失败的过程不表（ = = ），最后在精子大大的指导下才换了个u盘搞定了。</p><p>可是习惯了eos的桌面以后用其他的都不怎么习惯，都没有eos的漂亮/流畅（卡死不算 = = ）。特别是eos可以自己设置桌面热区，比如我的鼠标滑到右上角预览所有窗口/右下角最小化当前窗口/左下角切换工作区，一系列操作都特别炫酷。</p><p>好吧好吧所以呢，我最后还是重装了elementory os。前一段时间在家里用起来都没啥大问题，最近eos又开始抽风了，又是动不动卡死，完全不能忍啊。有时候在听歌，有时候在刷网页，然后突然卡死就只能长按电源键强制重启了。</p><p>昨天在v2ex看到有人说<a href="http://www.v2ex.com/t/102044" target="_blank" rel="noopener">chrome占用内存的问题</a>，我才检查我的chromium内存。然后我发现这货特别占资源啊，cpu经常50%+，内存也是几百兆。最后我决定对它下手了。</p><p>我先禁用chromium了大部分扩展，只留了两个（SwitchySharp和any.do）。本以为事情会有好转。嗯，我果然太天真了，问题依旧，而且cpu和内存也没降多少。</p><p>好吧我承认这娃没救了，转战firefox。使用习惯不同，ui不习惯（虽然我套了一个fxchrome的皮），书签导入麻烦，没有满意的扩展。好吧好吧，谁让我没办法，一一忍了，然后内存和cpu占用也降下来了。</p><p>嗯，你一定猜到结局了。我果然太天真了，过了一会又卡死了。。。。。。。。。wocao%7c$^389q&amp;*dj</p><p>怒删firefox，然后在网上找其他解决办法。比如</p><ul><li><a href="http://tieba.baidu.com/p/2870702006" target="_blank" rel="noopener">elementaryos无故死机的情况大家遇见过吗</a></li><li><a href="http://tieba.baidu.com/p/2713702964" target="_blank" rel="noopener">关于死机的问题</a></li><li><a href="http://ruby-china.org/topics/13471" target="_blank" rel="noopener">Ubuntu 13.04 老是更新就死机怎么破？</a></li><li><a href="http://www.elementaryupdate.com/2013/08/top-things-to-do-after-installing-luna.html" target="_blank" rel="noopener">Top Things To Do After Installing Luna</a></li></ul><p>基本上确定是内核的问题了，eos是基于ubuntu12.04的，内核版本为3.2，不支持hd4000的核心显卡，升级下内核版本就好了。</p><p>所以只需要一句命令就好了：</p><pre><code>sudo apt-get install linux-generic-lts-raring</code></pre><p>现在已经正常使用一整天了，依旧用chromium。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;真是被折腾死了，要看解决办法请直接跳到结尾。。&lt;/p&gt;
&lt;p&gt;年前的时候eos就是这样频繁卡死，tty调不出来，鼠标界面卡住不动。自己又找不到啥原因，最后干脆卸载了eos，转战其他发行版。期间因为不知道u盘有问题，换了N个发行版装了几十遍都失败的过程不表（ = = ），最后
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://faceair.me/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>2013 年终总结</title>
    <link href="https://faceair.me/2013/12/31/2013%20%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://faceair.me/2013/12/31/2013 年终总结/</id>
    <published>2013-12-30T16:00:00.000Z</published>
    <updated>2018-01-21T06:05:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>记得18岁的时候有认真写过一个总结，当时计划每年给自己一个总结的。但是后来没能每年坚持下来，想想还是有些遗憾，而现在我已经20岁了。</p><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>年初的时候还在英语调频台，那时候刚开始学习PHP大概一个多月，基本语法都没掌握全。花了一段时间学PHP，那时微信能简单地查询天气、笑话、小黄鸡一些东西。等过完了年跟着武大助手做查分、续借一些东西，当时太菜了，现在三天可以完成的东西当时断断续续写了一个多月。<br>记得那时lucy老是催我去吃饭，也记得有天周五感觉胸闷快猝死的感觉。那一个月是我最努力的时候吧，进步也很快，PHP总算是入门了。</p><p>后来就闲着了，有断断续续地用平板看书，一直到暑假看了正则表达式、python基础教程、搜索引擎原理、设计模式、面对对象一些东西。其他的代码没写多少，写了一个<a href="http://zhihudaily.sinaapp.com" target="_blank" rel="noopener">知乎日报</a>（现日PV 3K）、<a href="https://github.com/faceair/kdtx" target="_blank" rel="noopener">快递提醒</a>（已弃坑）。<br>精通正则表达式看了一半，边看边忘。现在会用基本的正则语句，不过也够用了。你们完全猜不到我不会正则的时候是怎样写几十行截取字符串的。。。<br>搜索引擎原理看了个大概，然后用简单地倒排索引实现了知乎日报的搜索，尽管代码很糙但是效果还挺好。后来因在SAE云豆开销过大，把搜索撤销了。<br>python看了一点，慢慢摸索写了一个爬虫，把我们图书馆的19W图书资料爬下来了。这些资料后来用在微信里面实现搜书，比以前curl快多了 : ）<br>暑假的时候我做的微信关注数达到了5k，要知道我们学校总共也才2w人啊。当时后台日消息数达到1w多，自信心爆棚。<br>面对对象和设计模式理解一些以后就在构想新的微信后台，之前代码拼凑太厉害写不下去了只好重写，现在回来看当时的设计隐隐有些MVC架构的雏形了。</p><p>到九十月份就在慢慢地写新的微信后台，一直到宣传部找到我给学校做微信，才在压力下把一些细节完成了，因为一些原因最终上线的还是阉割版。后来突然知道换了教务系统，手忙脚乱又花了几天把带验证码的新的教务系统搞定。<br>这个微信平台也是我目前为止写得最大的一个项目了，共28个文件，2K多行代码。其实还是有很多地方处理地不够好，等我下次重构吧。</p><p>十月份家里终于给买了电脑，我写代码才方便了不少。然后日常用了两个多月的ubuntu，学了些linux的基本使用知识。自己尝试<a href="http://lucy.faceair.net/archives/311" target="_blank" rel="noopener">配置了台VPS</a>，后来才有胆量拉<a href="http://www.ricter.info/" target="_blank" rel="noopener">萝莉</a>和<a href="http://qwe7002.tk/" target="_blank" rel="noopener">qwe</a>合租。linux鸟哥教程也还没看完，这也是一个坑。。</p><p>现在初学框架，刷完了CI的用户手册，大致理解了MVC架构。这个<a href="https://github.com/faceair/airblog" target="_blank" rel="noopener">airblog</a>是我第一个练手的作品，以后我再多试试写写更复杂的东西。</p><p>现在我又加入了图书馆的一个技术小组，大家协作写几个网站，包括荐购和好书推荐。貌似没什么太大难点，荐购和推荐主要是写好豆瓣的图书爬虫，然后跟本地的数据整合，然后前端显示就可以了。<br>初步拟定的是用python+django架构，主要是我还基本不会python，寒假来恶补。。</p><p>下一步是熟悉框架、python、前端、计算机原理和算法。</p><h3 id="朋友"><a href="#朋友" class="headerlink" title="朋友"></a>朋友</h3><p>上学期的时候还在英语调频台，平时活动挺多的。特别是到最后的台庆前一段时间，因为准备节目认识了全台大部分人。那还是在学跳舞，一个<a href="http://v.youku.com/v_show/id_XNTU4NTQyODM2.html" target="_blank" rel="noopener">爵士</a>（41:27）、一个<a href="http://v.youku.com/v_show/id_XNTY2ODQzNjEy.html" target="_blank" rel="noopener">搞怪</a>（不要问哪个是我。。）的。毕竟业余，有些不忍直视。。。</p><p>说到社团，其实有点觉得挺对不起前任网络部部长的。他从我进调频台开始就特别照顾我，单独请我吃饭谈话都很有几次。最后我还是义无反顾丢下自己的一堆烂摊子走了，最后连合适的接手的人都没找到。<br>英语调频台最大问题在于它本身已经逆潮流了，而本来我还有个很大的计划，可以借力校园新媒体振兴它的。可是台里各方面有能力的人实在是没有，我看不到多大希望。自己挑的担子太大，各方面铺不开只会累着自己。而我也无意在里面寻个闲职混日子，我还有好多事要做。所以最后绝决然地走了，这里向后面接我烂摊子的坤坤表示谢意。</p><p>暑假才开始在<a href="https://www.v2ex.com/t/95562" target="_blank" rel="noopener">精英盒子</a>里面冒泡，慢慢认识里面了好多大神。精子个大神到变态的不算，还有ricter、wxy、oran、cry。。cry是大二貌似，ricter大一，其他都是高中 = = 每个都是完虐我这种渣渣啊，每次出没压力都很大的说。。</p><p>除了每天跟盒子里面的大神扯淡外，貌似没有其他多少活动了。再就是跟室友上一起课、吃饭什么的，比较消停，这学期也才慢慢跟寝室内部搞好了关系。</p><p>一直到这个学期末，才又加入了两个组织。一个是学校的宣传部，一个是图书馆的技术小组。两边的同事大部分都不是同龄人啊，宣传部这边主要是大四的实习生、图书馆这边大部分是老师。感觉有点怪怪的，希望下学期合作愉快。</p><h3 id="妹纸"><a href="#妹纸" class="headerlink" title="妹纸"></a>妹纸</h3><blockquote><p>此内容过于得瑟，暂不开放</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记得18岁的时候有认真写过一个总结，当时计划每年给自己一个总结的。但是后来没能每年坚持下来，想想还是有些遗憾，而现在我已经20岁了。&lt;/p&gt;
&lt;h3 id=&quot;技术&quot;&gt;&lt;a href=&quot;#技术&quot; class=&quot;headerlink&quot; title=&quot;技术&quot;&gt;&lt;/a&gt;技术&lt;/h3
      
    
    </summary>
    
    
      <category term="总结" scheme="https://faceair.me/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>配置多用户的虚拟主机</title>
    <link href="https://faceair.me/2013/11/30/%E9%85%8D%E7%BD%AE%E5%A4%9A%E7%94%A8%E6%88%B7%E7%9A%84%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/"/>
    <id>https://faceair.me/2013/11/30/配置多用户的虚拟主机/</id>
    <published>2013-11-29T16:00:00.000Z</published>
    <updated>2018-01-21T06:07:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直想要个香港服务器，米国服务器太远，各种云间歇性抽风（sae抽得丧心病狂啊！！）。如果放微信接口，再加上还要curl国内的教务处，速度完全跟不上。 前两天看到v2ex上的locvps做活动，<a href="http://www.v2ex.com/t/89851" target="_blank" rel="noopener">香港1G 41元</a>，就咬咬牙从<a href="http://rpvhost.net" target="_blank" rel="noopener">RP主机</a>搬过去了。后来又拖了qwe7002一起合租，均摊下来20块一个月就还挺划算的。</p><p>服务器的简单配置自不必细说，用一个<a href="https://github.com/lj2007331/lnmp" target="_blank" rel="noopener">lnmp脚本</a>半个小时搭完，有些不常用的服务可以再安装完成后先停止。麻烦点的就是多用户的权限控制了，我自己的数据和权限要跟qwe7002的完全分离，而当一个站点被黑时也不能影响全局。</p><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>先新增两个用户分别给予对应的文件权限。nginx会以同组用户www身份访问目录，所以建议将文件目录权限设为750或更低。要禁止某些文件或目录从web访问时,可以将其权限设为660（仅当前用户访问）。</p><pre><code>adduser faceairpasswd faceair   //设定用户密码chmod 750 /home/faceair -R</code></pre><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>公用的mysql数据库提供了严格的多用户权限控制，使用phpmyadmin面板新建一个用户”给以 用户名<em> 开头的数据库 (username</em>%) 授予所有权限”,不给予全局权限就够了。</p><pre><code>CREATE USER &apos;faceair&apos;@&apos;%&apos; IDENTIFIED BY &apos;***&apos;;GRANT USAGE ON *.* TO &apos;faceair&apos;@&apos;%&apos; IDENTIFIED BY &apos;***&apos; WITH MAX_QUERIES_PER_HOUR 0 MAX_CONNECTIONS_PER_HOUR 0 MAX_UPDATES_PER_HOUR 0 MAX_USER_CONNECTIONS 0;GRANT ALL PRIVILEGES ON `faceair\_%`.* TO &apos;faceair&apos;@&apos;%&apos;;</code></pre><h4 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h4><p>默认nginx以www用户运行，为了能让nginx访问到用户文件，还要将www添加到对应用户的用户组，处理静态文件请求。</p><pre><code>gpasswd -a www faceair</code></pre><p>通过lnmp安装包里面的vhost.sh可以添加nginx配置，配置添加后对文件权限还要重新修改。默认会添加配置到/usr/local/nginx/conf/vhost目录对应域名。</p><h4 id="php-fpm"><a href="#php-fpm" class="headerlink" title="php-fpm"></a>php-fpm</h4><p>nginx本身不能处理PHP，它只是个web服务器。当接收到php请求后，需要转发到php-fpm对应的UNIX socket文件。修改对应域名的nginx配置。</p><pre><code>location ~ .*\.(php|php5)?$  {    fastcgi_pass unix:/tmp/faceair-fpm.sock;    fastcgi_index index.php;    include fastcgi.conf;}</code></pre><p>给每个用户都建立单独的进程池,每个进程池表现为一个UNIX socket文件。修改/usr/local/php/etc/php-fpm.conf，添加一行。</p><p><code>include = /usr/local/php/etc/pool.d/*.conf</code></p><p>再添加目录/usr/local/php/etc/pool.d/，在目录中添加对应用户faceair.conf。</p><pre><code>[faceair]user = faceairgroup = faceairlisten = /tmp/faceair-fpm.socklisten.owner = faceairlisten.group = faceairlisten.mode = 0660pm = dynamicpm.max_children = 10pm.start_servers = 3pm.min_spare_servers = 1pm.max_spare_servers = 3</code></pre><p>基本配置就是这样了，最后重启nginx和php-pfm。</p><pre><code>/usr/local/nginx/sbin/nginx -s reloadkill -USR2 `cat /usr/local/php/var/run/php-fpm.pid`</code></pre><p>我再考虑怎么写个脚本来管理这些配置文件。</p><p>参考：</p><ul><li><a href="http://jysperm.me/program/810/comment-page-1#comment-885" target="_blank" rel="noopener">http://jysperm.me/program/810/comment-page-1#comment-885</a></li><li><a href="http://everet.org/2012/11/multi-user-nginx-php-server.html" target="_blank" rel="noopener">http://everet.org/2012/11/multi-user-nginx-php-server.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直想要个香港服务器，米国服务器太远，各种云间歇性抽风（sae抽得丧心病狂啊！！）。如果放微信接口，再加上还要curl国内的教务处，速度完全跟不上。 前两天看到v2ex上的locvps做活动，&lt;a href=&quot;http://www.v2ex.com/t/89851&quot; tar
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://faceair.me/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>PHP还原强智教务管理信息系统加密过程</title>
    <link href="https://faceair.me/2013/03/18/PHP%E8%BF%98%E5%8E%9F%E5%BC%BA%E6%99%BA%E6%95%99%E5%8A%A1%E7%AE%A1%E7%90%86%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B/"/>
    <id>https://faceair.me/2013/03/18/PHP还原强智教务管理信息系统加密过程/</id>
    <published>2013-03-17T16:00:00.000Z</published>
    <updated>2018-01-21T06:06:23.589Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://jybox.net/220-%E5%B0%86%E4%B8%80%E6%AE%B5js%E5%92%8Casp%E8%BD%AC%E6%8D%A2%E6%88%90php" target="_blank" rel="noopener">求助帖</a>，还是自己解决了。</p><p><strong>概述</strong></p><p>教务系统地址<a href="http://jwxt.whsw.cn/" target="_blank">http://jwxt.whsw.cn/</a>，你会发现登陆只能用ie浏览器，他喵的chrome和firefox都不支持。用其他浏览器登录时会提示密码错误，原因是他会先在前端加密密码再跟服务器通讯。而加密用的js和vbs，其他浏览器都只能js加密，vbs加密过程就不支持了，所以加密不完全导致提示密码错误。唉，这套系统也太老了，最后更新还是2005年，无力吐槽。</p><p><strong>js加密还原</strong></p><p>原过程</p><pre><code>var pwd = theform.PassWord.value;var rndNum = 394058;rndNum = rndNum.toString();var curPos = 0;var tmpStr,EnCryptStr = &quot;&quot;;for(Cnt=0;Cnt&lt;pwd.length;Cnt++){  if(Cnt % rndNum.length == 0 ) curPos = 0; tmpStr = pwd.substring(Cnt,Cnt+1);  EnCryptStr += String.fromCharCode(tmpStr.charCodeAt(0) - Cnt - rndNum.substring(curPos,curPos+1));  curPos +=1;}theform.PassWord.value = EnCryptStr;//Assigned the EncryptPassword value to the PassWord TextFiledtheform.EnRndNum.value = rndNum;</code></pre><p>用php还原</p><pre><code>$pwd = &quot;&quot;;$rndNum = &quot;394058&quot;;$curPos = 0;$tmpStr = &quot;&quot;;$EnCryptStr = &quot;&quot;;for($Cnt=0;$Cnt&amp;amp;lt;strlen($pwd);$Cnt++)  {   if($Cnt % strlen($rndNum) == 0 ) $curPos = 0;   $tmpStr = substr($pwd,$Cnt,1);    $EnCryptStr = $EnCryptStr. fromCharCode(charCodeAt($tmpStr) - $Cnt - substr($rndNum,$curPos,1));                      $curPos +=1;  }echo $EnCryptStr;echo &apos;&apos;&amp;amp;lt;br&amp;amp;gt;&apos;&apos;;echo $rndNum;echo &apos;&apos;&amp;amp;lt;br&amp;amp;gt;&apos;&apos;;echo EncryptString($EnCryptStr);function fromCharCode($codes) {  if (is_scalar($codes)) $codes= func_get_args();  $str= &apos;&apos;&apos;&apos;;  foreach ($codes as $code) $str.= chr($code);  return $str;}function charCodeAt($word) {  if (is_array($word))    $arr = $word;  else    $arr = str_split($word);  $bin_str = &apos;&apos;&apos;&apos;;  foreach ($arr as $value)    $bin_str .= decbin(ord($value));  $bin_str = preg_replace(&apos;&apos;/^.{4}(.{4}).{2}(.{6}).{2}(.{6})$/&apos;&apos;,&apos;&apos;$1$2$3&apos;&apos;, $bin_str);  return bindec($bin_str);}</code></pre><p><strong>vbs加密还原</strong></p><p>原函数</p><pre><code>Function EncryptString(InputText , ThePassword )&apos;&apos;用户口令加密  Dim il_bit, il_x, il_y, il_z, il_len, i  Dim is_out  Password = InputText  il_len = Len(Password)  il_x = 0  il_y = 0  is_out = &quot;&quot;  For i = 1 To il_len    il_bit = AscW(Mid(Password, i, 1)) &apos;&apos;W系列支持unicode    il_y = (il_bit * 13 Mod 256) + il_x    is_out = is_out &amp;amp; ChrW(Fix(il_y)) &apos;&apos;取整 int和fix区别: fix修正负数    il_x = il_bit * 13 / 256  Next  is_out = is_out &amp;amp; ChrW(Fix(il_x))  Password = is_out  il_len = Len(Password)  il_x = 0  il_y = 0  is_out = &quot;&quot;  For i = 1 To il_len    il_bit = AscW(Mid(Password, i, 1)) &apos;&apos;取前4位值   il_y = il_bit / 16 + 64    is_out = is_out &amp;amp; ChrW(Fix(il_y)) &apos;&apos;取后4位值    il_y = (il_bit Mod 16) + 64    is_out = is_out &amp;amp; ChrW(Fix(il_y))  Next  EncryptString = is_out  End Function}</code></pre><p>用php还原</p><pre><code>function EncryptString($Password){    //密码前端加密部分  $il_len = strlen($Password);  $il_x = 0;  $il_y = 0;  $is_out = &quot;&quot;; for($i=0;$i&lt; $il_len;$i++){   $il_bit = ord(substr($Password, $i, 1));    $il_y = ($il_bit * 13 % 256) + $il_x;   $is_out = $is_out. Chr(fix($il_y));   $il_x = $il_bit * 13 / 256; } $is_out = $is_out. Chr(fix($il_x)); $Password = $is_out;  $il_len = strlen($Password);  $il_x = 0;  $il_y = 0;  $is_out = &quot;&quot;; for($i=0;$i&lt;$il_len;$i++){    $il_bit = ord(substr($Password, $i, 1));    $il_y = $il_bit / 16 + 64;          $is_out = $is_out. Chr(fix($il_y));    $il_y = ($il_bit % 16) + 64;          $is_out = $is_out. Chr(fix($il_y));  } return $is_out;}function fix($il_y) { if(floor($il_y) &lt; 0){    return floor($il_y)+1;  }else{    return floor($il_y);  }}</code></pre><p>自此php就完美还原了两个加密过程，再模拟登陆就简单了。<br>他喵的调试一下午啊啊啊啊啊、、、</p><ul><li>2013.7.06 更新 第二段加密函数里面floor不能完全还原fix函数，所以自定义fix函数。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://jybox.net/220-%E5%B0%86%E4%B8%80%E6%AE%B5js%E5%92%8Casp%E8%BD%AC%E6%8D%A2%E6%88%90php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;求助帖
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://faceair.me/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>18岁，不断成长。</title>
    <link href="https://faceair.me/2011/09/30/18%E5%B2%81%EF%BC%8C%E4%B8%8D%E6%96%AD%E6%88%90%E9%95%BF%E3%80%82/"/>
    <id>https://faceair.me/2011/09/30/18岁，不断成长。/</id>
    <published>2011-09-29T16:00:00.000Z</published>
    <updated>2018-01-21T06:05:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实很巧，我生日那天正好是忘语大婚的日子。</p><p>一不小心迈过了18岁的门槛，当我还没有准备好的时候，很神奇地就成年了。而如今，我也必须以一个更加理性的眼光来审视自己的行为，以一个更加严谨。负责的态度来对待自己的生命。</p><p>进入高四，我突然感觉好像被抽空了，好像失去了原有的一切，以一个十分空虚的状态的进入这里的生活。我也一直尝试寻找我所失去的东西，但是没有找到。这让我想起了三年前的自己，也是如此地感觉空虚。不过那个时候并不怀念过去，只是觉得失去了生活的方向，而如今貌似包含了这两个方面。</p><p>人们在小的时候其实是群居动物，而人生就是一个从平原向森林的前进过程。在前进过程中因为越来越多的牵绊而使你的同伴一个一个失散，到最后你可能孤身一人。很难想象，当某一天我们被各自的前途牵绊，被各自的家庭所牵绊，被种种利益所牵绊，被各种纷繁复杂的人际关系所牵绊，被各种矛盾所牵绊。那时，你不再是你，我不再是我，我们还能找回如今的纯真吗？</p><p>我玩过了高中三年，我的最大收获是因为很多很多事而是我更加成熟。我学会了有所坚持和有所放弃，我学会了以一个合适的距离去对待朋友，我学会了兀自感伤和伪装情感，我学会了认真对事和以诚待人，我学会了更加理性和客观地看人看事，我学会了沉默和内敛。<br>而如今，我在这里，我在补校，我在高四。没有朋友，没有爱人，没有梦想，好像一只即将启程的帆船却没有目的地。不过还好，我父母让我考个好点的大学，所以我尽管有些盲目，但还是在很努力地前进。</p><p>我以前曾经标榜过自己不怀恋过去，但是如今我的确非常想念那些朋友，想念那些没心没肺整天玩乐的荒唐日子。我感觉那时候的自己好像脑残，不懂得替未来担忧，不懂得替自己担忧，整天疯玩。然后一路嘻嘻哈哈走过了高中三年，最后各自分离走向不同的方向。有时候突然会有在某个时间想起某个人，然后一阵失神。可是，不管未来怎么变，我们都不可能回到从前。我觉得以前的自己还算是活跃分子，可是现在我不愿意跟那些“陌生人”打交道，不愿意将自己融入那个班级。有人说，怀恋过去是一种懦弱的表现，我想这大概是对的。</p><p>曾经的我十分渴望拥有一份完美的爱情。但是因为种种原因，事情的发展走向了与我预料相反的方向，当然这并不是谁的过错。然后，我在高二颓了很久，我感谢很多很多那个时候帮助过我的人。到后来，我们成了还算不错的朋友。对于这种没有办法的事情，我也只能说：“祝你幸福”。</p><p>最后是关于梦想。如果你两个月前问我，我绝对可以给你一个非常明确的答复。但是，现在，我只能告诉你，有点乱，不清楚。首先，是一个我非常喜爱的行业在一段时间后，在我甚至都还没有进入的时候，我发现自己的激情已经有所减退了。这是非常可怕的，因为这个行业需要的就是无比的热情，否则很难从中有所成就。其次，是前途与钱途的矛盾，我不是一个俗人，但不代表我以后也不是。目前的现实就是，这个行业中只有少数顶尖的牛人才能拥有好的待遇，稍次一些的待遇也会差很多。我并不敢在将来让我挑起家庭的重担后还能很无耻地告诉我的妻女：“我喜欢这份工作，没钱又怎么样？”那真是欠打。所以，很明显，国企。公务员。电力什么的就稳定轻松地多。</p><p>其实，有时候想的多了就会很累。那些迈不过的坎。那些想不明白的问题都交给时间来解决。</p><p>而如今，我18岁了。</p><hr><p><strong>后记（10.2）：</strong></p><p>18岁那天，我就有一种强烈的倾诉的愿望。希望能跟某个人畅谈一下我现在的生活状态或者我的过去或者将来。但是很遗憾，我没有找到这样的人。所以，前天我用日志把我的一些想法表达了出来。</p><p>但这并不代表我变了多少多少，也不代表我从此消沉颓废。很多事我看的很清楚，这里更多的只是对自己高中生活的总结和一些暂时的迷惘。而实际上，这些都无关大局，并不会影响我日渐犀利的判断力。为的只是在这里留下一个证据，供自己日后追忆时想起有过这样或那样一些日子，如此而已。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实很巧，我生日那天正好是忘语大婚的日子。&lt;/p&gt;
&lt;p&gt;一不小心迈过了18岁的门槛，当我还没有准备好的时候，很神奇地就成年了。而如今，我也必须以一个更加理性的眼光来审视自己的行为，以一个更加严谨。负责的态度来对待自己的生命。&lt;/p&gt;
&lt;p&gt;进入高四，我突然感觉好像被抽空了
      
    
    </summary>
    
    
      <category term="总结" scheme="https://faceair.me/tags/summary/"/>
    
  </entry>
  
</feed>
